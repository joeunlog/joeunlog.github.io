{"0": {
    "doc": "Setting environment",
    "title": "Setting environment",
    "content": "Summary () {: .text-delta } 1. TOC {:toc} # Anaconda 설치 1. [https://www.anaconda.com/download/](https://www.anaconda.com/download/) 접속 2. Individual Edition 선택 3. 각자 OS에 맞는 Installer 다운로드 > ex. Anaconda3-2020.07-Windows-x86_64.exe 4. Installer 실행 > Install location(설치 경로)는 필요에 따라 변경 가능 ex. d:/영문이름/anaconda > **❗ PATH environment variable은 꼭 체크 상태로** # Jupyter notebook 실행 1. Anaconda Prompt 실행 2. 프롬프트에 아래 명령 입력 ``` jypyter notebook \"소스코드 디렉토리\" ``` ## Jupyter notebook 주요 단축키 * 셀 선택 모드 (Command Mode) | 기능 | 단축키 |:---------------------------------|:--------------------------| 위로 셀 추가 | [a] | 아래로 셀 추가 | [b] | 선택 셀 삭제 | [d][d] (d를 두번 누름) | 선택 셀 잘라내기 | [x] | 선택 셀 복사하기 | [c] | 선택 셀 아래에 붙여넣기 | [p] | 선택 셀과 아래 셀과 합치기 | [shift] + [m] | 실행결과 열기/닫기 | [o] | Markdown으로 변경 | [m] | Code로 변경 | [y] | 파일 저장 | [cmd] + [s] 또는 [s] | 선택 셀의 코드 입력 모드로 돌아가기 | [enter] | * 코드 입력 모드 (Edit Mode) | 기능 | 단축키 |:---------------------------------|:--------------------------| 선택 셀의 코드 전체 선택 | [ctrl] + [a] | 선택 셀 내 실행 취소 | [ctrl] + [z] | 선택 셀 내 다시 실행 | [ctrl] + [y] | 커서 위치 라인 주석처리 | [ctrl] + [/] | 선택 셀 코드 실행 | [ctrl] + [enter] | 선택 셀 코드 실행 후 다음 Cell로 이동 (없으면 새로 추가) | [shift] + [enter] | 커서 위치에서 셀 둘로 나누기 | [shift] + [ctrl] + [-] | 셀 선택 모드로 돌아가기 | [esc] 또는 [ctrl] + [m] | # Python 설치 1. [www.python.org/downloads](www.python.org/downloads) 접속 2. 원하는 버전의 Python installer 다운로드 3. Installer 실행 > Add Python 3.x to PATH 설정을 선택 : 파이썬이 어느 곳에서든지 실행될 수 있도록 ",
    "url": "/docs/python-study/01-set-environment.html",
    "relUrl": "/docs/python-study/01-set-environment.html"
  },"1": {
    "doc": "Data type",
    "title": "Data type",
    "content": "Summary () {: .text-delta } 1. TOC {:toc} # ",
    "url": "/docs/python-study/02-data-type.html",
    "relUrl": "/docs/python-study/02-data-type.html"
  },"2": {
    "doc": "2021-01-27",
    "title": "2021-01-27",
    "content": "1교시 - AWS_RDS - OLTP(online transaction processing)성 DB와 DW (Dataware house) - Amazon Redshift는 DW - DW는 대량 Read가 많이 일어남, 수정이 자주 일어나지 않음, 실시간 작업이 아님 - OLTP는 소량 Read로 많이 일어남 - DW랑 OLTP랑 너무 달라서 따로 씀 : 오라클을 쓴다고 해도 각 DB를 구성해놓고 씀 2교시 - 네트워크 계층 : VPC를 만들어 볼 예정 - VPN : 가상의 사설 네트워크 : 네트워크 용어임 - VPC : 가상의 사설 클라우드 - VPC 안에 서브넷 두 개를 만들어 볼 예정 - 서브넷 관련 : 255는 이진수로 11111111이다. 이진수로 1인 부분이 주소로 쓰는 부분이라는 뜻 : ex. 255.255.255.128 = 11111111.11111111.11111111.10000000 - 일반적으로 외부에서 RDS로 직접 연결은 불가능 : 실습시간에 강사님 서버에 들어간 것은 모든 것을 다 열어놨기 때문 : 주로 인스턴스에 DB를 관리하는 프로그램을 넣어놓고 이 인스턴스에 DB관련 요청을 통해 뭔가 작업이 이루어지는 것 3교시 - 4교시 - 서브넷 권장 사항 5교시 - DBMS마다 사용하는 포트가 다름 - 개인 실습 시작 (VPC) 6교시 - 개인 실습 계속 ",
    "url": "/docs/daily-learning-log/20210127.html",
    "relUrl": "/docs/daily-learning-log/20210127.html"
  },"3": {
    "doc": "2021-01-28",
    "title": "2021-01-28",
    "content": "1교시 - 아키텍처에서 NAT게이트웨이, EC2인스턴스 그 쪽 관련 - 다이어그램에서 자물쇠 표시는 private network를 의미 - 외부 네트워크는 일부 url만 열어줌 - EC2에서 외부 네트워크에 뭔가를 요청하는거고 NAT 게이트웨이를 통해 외부 네트워크로 나가게 된다 - 서브넷마다 라우팅테이블이 있는데, NAT로 나가게 되는 주소를 제한하는것임 - 클라우드에서 라우터가 따로 존재하지 않고, 라우팅 테이블은 서브넷마다 존재 - 결과적으로, 인터넷 게이트웨이와 연결돼야 외부 네트워크와 통신 가능 - VPC는 어떤 리전 안에 만드는 것으로 여러 개의 리전에 걸쳐서 만들 수 없음 - 단일 VPC 패턴 , 다중 VPC 패턴, 복수 계정 패턴은 규모 차이 (첨부된 문서 참고) - 계정당 VPC 5개 - AWS에는 Hard limit, Soft limit 서비스가 있는데 이거는 Soft limit으로, 요청하면 제한조건 바꿔줌 (늘릴 수 있다는 얘기) - IP 한 칸당 8bit로, CIDR/16인 VPC는 앞의 2칸이 네트워크 주소 - 즉 CIDR /숫자 는 네트워크 주소가 어디까지인지를 알려줌 : 호스트 주소로 어디까지 쓸 수 있는지를 나타냄 : CIDR /32면 4칸 모두 네트워크 주소이므로 호스트 주소는 1개인 것 - 이 숫자를 8의배수가 아닌 숫자로 쓸 수도 있음 : bit단위로 생각하면 됨 : 즉, 10진수로 생각하면 IP주소는 총 4칸이지만, 2진수로 하면 8개씩 4세트의 숫자임 : 앞에서부터 해당 숫자의 비트 수 만큼이 네트워크 주소 - 퍼블릭 서브넷, 프라이빗 서브넷을 각각 만들 때 CIDR를 지정해서 네트워크 주소와 호스트 주소를 나눔 - CIDR랑 서브넷마스크는 다른 점이 존재 : 용도 - 서브넷 마스크는 호스트 주소를 갈라서 쓰고 싶어서 쓰는 것, 서브넷 마스크로 원래 호스트주소 영역도 네트워크 주소로 지정해서 네트워크 영역을 갈라서 쓰는 거 - 즉 서브넷 마스크를 하나 쓰면 네트워크가 둘로 갈라짐 - CIDR은 내 네트워크 주소가 어디까지인지를 알려주는 용도 2교시 - VPC 계속 - 어제 실습한 내용 복습 3교시 - 어제 실습한 내용 복습 계속 - Windows server EC2 생성 - 원격연결 - anaconda 설치 4교시 - Django 설치 - 윈도우 방화벽 해제 5교시 - Django - 아키텍처 : 시스템 전체 기본 설계, 규칙 : 시스템 아키텍처 : hw아키텍처 + sw아키텍처 - 아키텍처 패턴/스타일 : 설계노하우 : 문제영역, 이름 : (시스템전체-비기능품질) : ex. sw 아키텍처 패턴 2가지 : MVC, Layer - 디자인 패턴 : 설계노하우 : 문제영역, 이름 : (시스템전체-비기능품질) : ex. singleton, proxy - Django에서는 MVC(Model, View, Controller)가 아니라 MVT(Model, View, Template)로 씀 6교시 - MVC에서 View는 화면 : HTML문서 - model은 C.R.U.D : DB연결 - Controller는 모든 제어 : 고객 요청 받고 model에 DB 조회 요청하고 답 받은거를 View에 화면출력하라고 명령 - 개발 프레임워크 : sw 개발의 뼈대를 구현해 놓은 것 : python에서는 Django, Flask 등이 있음 : 주로 범용적인 것을 구성해놓음 : 코드를 구현해놓으면 프레임워크가 그 코드를 가져다가 씀 - 라이브러리나 패키지는 미리 개발해놓은 코드들의 묶음으로, 사용자가 패키지에 있는 것들을 호출해서 씀 : 라이브러리나 패키지가 사용자의 코드를 가져다가 쓰지는 않는다는 것이 프레임워크와의 차이점 - Django의 MTV는 화면에 표시된 버튼을 누르는게 사용자 요청같은거니까, 사용자 요청을 받는 부분을 View로 표기 - Template은 MVC의 View와 같음 - 개인 컴퓨터에 Django 설치 - 파이참에서 터미널을 작동시키는 이유 : 프로젝트를 새로 만들면 가상 실행환경이 생김(venv) : Django를 이 실행환경에 설치하기 위함 - Base 실행환경은 Django 설치 안된 상태가 됨 : 이런 식으로 여러 버전의 python을 쓸 수도 있음(참고) - Django를 설치하면 SQLite3이라는 DB도 같이 설치됨 + DBMS, WebServer, WAS, PythonMVC Framework 7교시 - 프로젝트 회의 ",
    "url": "/docs/daily-learning-log/20210128.html",
    "relUrl": "/docs/daily-learning-log/20210128.html"
  },"4": {
    "doc": "2021-01-29",
    "title": "2021-01-29",
    "content": "1교시 . - 어제 복습 . 2교시 . - 프로젝트는 2월 9일 발표 예정 . - 2월 2, 3, 4, 8일은 온전히 프로젝트하고 5일에는 수업 (고가연성 아키텍처) . - 2월 1일에는 게시판 만들기 실습 예정 . - Django 웹 어플리케이션 개발 실습 시작 . - Python Class로 SQL의 테이블이 자동 생성하기 . : models.py 파일에 클래스 정의, models.Model을 상속하는 클래스를 작성 . : ex. from django.db import models class Quetion(models.Model): . - Class와 테이블이 맵핑이 되고, class로 생성한 객체가 테이블의 ............ ORM(Object Relational Mapping 객체관계맵핑) . 3교시 - myDjangoSite 실습 : Question class 생성, admin 설정 . : admin.py 파일에 에러가 3개 뜨는데, 이건 로컬상태에서 해당 코드가 내용을 못찾아서 그러는거고 실행 잘 됐으면 문제 없음 . - 교재에서의 View(Django MVT)는 MVC에서는 Controller를 의미 . 4교시 . - View, Template 개발 . 5교시 . - 127.0.0.1 : 현재 컴퓨터 라는 의미 . - 그 뒤의 8000은 현재 Django가 쓰는 서버의 포트넘버 . 6교시 . - choice 데이터 추가하기 . 7교시 . - 자습 . ",
    "url": "/docs/daily-learning-log/20210129.html",
    "relUrl": "/docs/daily-learning-log/20210129.html"
  },"5": {
    "doc": "2021-02-01",
    "title": "2021-02-01",
    "content": "1교시 - 복습 - SW 개발 프레임워크(MVC) : 장고, 스프링 등등 : 스프링은 ORM 포함하지 않아서 따로 MyDa뭐시기를 씀 2교시 - 파이썬 쉘로 데이터 조작 실습 - Question.objects.filter : 모델명(테이블에 매핑), 객체들(데이터들), filter(WHERE와같음) - 컬럼명__조건 : 해당 컬럼에서 조건에 해당하는 것들 찾음 : ex. question_text__startswith='What' , pub_date__year=2005 - 객체.delete() : 레코드 삭제 함수 - 객체.save() : 새로운 데이터 생성 혹은 데이터 수정 함수 - 새로운 프로젝트 생성 : MyDjangoSite2 : 게시판 만들기 - 클래스 선언(테이블 생성)에서 : null = False : NOYNULL : primary_key = True : 기본키로 설정 : on_delete = CASCADE : 부모데이터가 삭제되면 포린키의 자식데이터도 삭제 : on_delete = SET_DEFAULT, default=\"\" : 부모데이터 삭제시 자식데이터 default값으로 바뀜 : on_delete = SET_NULL : 부모데이터 삭제시 자식데이터 NULL 3교시 - 게시판 만들기 계속 4교시 - 폼 클래스 활용 장점 - 폼 클래스를 form.py에 생성 - templates/login.html을 생성하여 form이 들어가는 로그인화면 생성 : {{form}}으로 쓰면 클래스로 선언했던 것에 맞게 html태그가 생성됨 : ex. 변수명 => name, 라벨 => 라벨 - view.py에서 login 함수 수정 : form = LoginForm(), return에 {'form':form} - session : 논리적 연결 : 카톡 서버가 있고, 내 컴퓨터에 카톡채팅 2개 띄워놨을 때, 물리적 연결은 1개, 논리적 연결은 2개 5교시 - 세션을 이어갈 때, 일종의 토큰을 발급받아서 토큰 아이디를 기준으로 내용을 저장, 통신을 이어갈 때 토큰 아이디를 전달하여 세션 진행되도록 - summit을 눌렀을 때 어디로 가야할 지 알려주는게 action : templates/login.html에서 아래의 input type summit을 클릭하면 form이 위의 url따라서 가는것임 - redirect : 요청 받은 주소 말고 다른 주소로 바뀌는 것 6교시 - 게시판 만들기 실습 계속 - 최종프로젝트 팀 선정 관련 : 최종 프로젝트는 현업분들이 멘토링해줌 : 멘토링은 기획 같은 부분 위주 - 개인적으로 주제에 대해 좀 생각해보고 - 2월 8~9일 쯤에 주제 관련, 예상 주제에 대해 알려줄 것(멘토 의견) - 그 후에 주제 좀 더 생각해보면서 팀 구성 시작해보기 - 2/16까지 팀 확정 : 총 5팀 - 2월 20일 이후에 멘토와 얘기해볼 수 있을 듯 - 3월 초부터 프로젝트 기획부터 시작할 듯 - 멘토링은 수업시간 이외의 시간으로 과정 끝날 때까지 : 총 40시간 - 6월 21일에 과정 종료인데, 이 날은 발표날이고 6월 18일까지 프로젝트 진행한다고 생각하면 됨 ",
    "url": "/docs/daily-learning-log/20210201.html",
    "relUrl": "/docs/daily-learning-log/20210201.html"
  },"6": {
    "doc": "2021-02-05",
    "title": "2021-02-05",
    "content": "1교시 - AWS 고가용성 아키텍처 - RDB는 완전 관리형 : 알아서 2중화 되어있는 서비스 - 고가용성 아키텍처는 중복이 기본, 가용영역은 두 개 써야함(같은 리전에서 다른 가용 영역) - 가용영역별로 서브넷을 구축, 서버 배치, DB 등을 중복시킨다 - 사실은 한 쪽의 시스템만 사용하고 있음 - load balancer가 중간에서 부하를 조정 (ALB) - 평상시에는 부하를 조정하다가 장애가 발생되면 헬스 체크로 인해 정상적인 쪽만 구동 됨 - 로드밸런스는 온프레미스에도 있는 기능 - 오토스케일링은 온프레미스에는 없음 - 24시간 돌리는 프로그램, 서버는 3~4개를 중복해서 씀 - 고가용성 아키텍처 사례2의 경우에는 아마존라우트S3가 리전 밖에 있음. - 따라서 부하에 따른 로드밸런스를 다른 리전에 보내줄 수도 있음 - 이번 프로젝트에서 오토스케일링은 안쓰는걸로 2교시 - 네트워크 구성 실습 - VPC 마법사로 만들면 라우팅 테이블도 자동으로 만들어짐 : 새로 만든 서브넷들에 연결 필요 - 라우팅 테이블에 가서 새로 생긴 vpc와 연결된 것이 2개 생성된 것 확인 - 상세를 봤을 때 , 라우팅에 NAT가 있는 것이 Private : private과 public 잘 구분해서 이름 써주기 3교시 - 네트워크 구성 실습 계속 4교시 - 네트워크 구성 간략 설명 - EC2는 원래 private subnet 안에 만드는게 일반적인데, 그렇게 하면 파일 올리는게 힘들어서 우리는 public에 생성할 것 5교시 - 6교시 - NAT랑 EIP는 만들어놓고 사용하지 않으면 요금이 나감? 7교시 - NAT(시간당 0.059USD, 처리 데이터비용별도), 탄력적IP는 비용이 나오므로 사용하지 않으면 바로 삭제하는 것이 좋다. ",
    "url": "/docs/daily-learning-log/20210205.html",
    "relUrl": "/docs/daily-learning-log/20210205.html"
  },"7": {
    "doc": "2021-03-29",
    "title": "2021-03-29",
    "content": "쉘 스크립트 . - 쉘 스크립트 : 쉘 프로그래밍을 할 때, 원하는 명령어를 sh파일에 작성하여 저장 - 실행방법 //반드시 파일의 실행권한 필요 절대경로를 명령어로 써서 실행 (ex. /home/user/hello.sh) 다만, /usr/bin 폴더에 넣어놓는 경우에는 파일명만 써서 실행 가능 (ex. Hello.sh) - 실행 프로그램 지정해서 실행하는 방법 두 가지 : shebang, 프로그램에서 스크립트파일이름 - shebang(셔뱅) : 쉘 스크립트 가장 윗 줄에 '#!' 기호로 표기, 이 스크립트를 실행할 프로그램 지정 (ex. #! /bin/python, #! /bin/perl, #! /bin/bash) : #! 뒤는 띄어도 되고 안띄어도 됨 특정 실행 프로그램을 사용하여 실행하는 경우에는 무시됨 - shebang이 없는 경우, 현재 쉘을 사용하여 실행하게 됨 - 스크립트파일이름 : 실행권한이 없는 스크립트도 실행 가능 - # : 주석, 실행 시 무시 . - 공백 자유롭게 사용 가능 - 디버그 옵션 사용 : 프로그램에서 -옵션 스크립트파일이름 -x : 실행할 코드가 아닌 실행할 내용을 출력 -v : 디버그 상태에서 스크립트 내 실행할 코드를 그대로 표시 -f : 스크립트 내 메타문자의 효력을 정지 - 스크립트 내 디버그 옵션 set -[옵션] : 해당 디버그 옵션 활성화 set +[옵션] : 해당 디버그 옵션 비활성화 Exit Status . - 종료 상태를 의미 - 명령어 실행 결과를 숫자로 표기 - 일반적으로 0이 정상 종료를 의미하지만 예외도 있음 - $? : 명렁어 실행시 종료 상태를 저장, 새로운 명령어 실행시 새로운 값으로 덮어 씀 변수 - Variable, 변경 가능한 데이터가 저장되는 공간 - 쉘 프로그래밍에서의 변수는 특정 유형이 없음 - 쉘 내에서 자유롭게 선언 및 사용이 가능 (ex. 변수이름=변수값. 변수이름=$변수이름) - 모든 입력값을 문자열로 인식 - 특별한 용도의 변수 $$ : 현재 실행중인 쉘의 PID $? : 이전 작업의 Exit Status $! : 백그라운드로 실행된 프로세스의 PID - 스크립트 내에서 선언된 변수는 스크립트 내에서만 유효 (지역변수) - 전역변수 : env로 조회되는 변수는 쉘 내에서 호출한 쉘에서도 접근 가능 - export : 해당 변수를 전역변수로 변경, env에 소속됨 - export = : 변수 생성과 전역변수로 변경을 동시에 산술연산 - expr : 산술연산 수식을 인자로 받아서 처리, 소수점 처리 불가능 ex. Expr 10+3 - bc : 산술연산 수식을 입력으로 받아서 처리(대화형), 소수점 처리 가능(scale 활용) ex. bc (대화형 시작) ex. echo 10/3 | bc ex. echo \"scale=3;10/3\" | bc - let 조건부실행 (Exit Status 관련) - 앞 명령의 실행 결과에 따라 뒤 명령의 실행 여부 결정 - && : 앞 명령이 정상적으로 실행될 경우에만 뒤 명령을 실행 - || : 앞 명령이 정상적으로 실행되지 않을 경우에만 뒤 명령을 실행 . 위치 매개변수(Positional Parameter) (c나 python에서 함수에 변수 넣는거랑 같은 의미) - 명령어 내에서의 위치 (인자, Argument) - $0 : 현재 실행중인 쉘 스크립트의 이름 - $1~ : 현재 스크립트 실행 시 사용된 인자(1번, 2번, 3번, … ) 10이 넘어가는 경우에는 ${10} 이런 식으로 사용해야함 - $# : 전체 위치매개변수의 개수 - $*, $@ : 위치매개변수 전체 - 예를 들어 cp 명령어의 경우, 맨 뒤 변수만 목적지고 앞에 몇 개의 변수가 들어가던 복사하려는 인자가 됨 - 가장 마지막 위치매개변수 접근 : eval echo \\$$# echo $$# : $$가 해석되어 사용 불가 echo \\$$# : \\에 의해 $는 일반 문자로 인식되고, $#값이 붙게 됨 eval echo \\$$# : eval에 의해 뒤쪽 $ 기호가 다시 인식되어 마지막 매개변수 값을 가져올 수 있게 됨 - set을 이용하여 현재 사용중인 쉘에서 사용할 위치매개변수를 지정할 수 있음 (ex. set a b c e d) grep (Globally Regular Expression Print) . - 파일 내에서 사용자가 지정한 내용을 검색 - 검색 내용 부분에는 정규화표현식(Regular Expression)을 사용 - 검색된 내용을 화면에 출력 - 일부 옵션의 경우 검색된 내용이 출력되지 않음 - 검색 실행시 검색 대상 파일에는 영향을 미치지 않음 - ASCII, 즉 텍스트 데이터를 대상으로만 사용 가능 - strings 명령어를 이용하여 문자열로 치환해서 사용 가능 - 옵션 -c : 패턴을 찾고, 찾은 패턴이 들어있는 '줄 수'를 출력 (패턴 개수 아님!!!) -I : 대소문자 구분하지 않음 -l : 패턴을 찾고, 출력은 하지 않으며, 패턴이 들어있는 파일의 목록만 출력 -n : 패턴을 찾은 후 출력되는 라인 앞에 줄 수를 표시 -v : 찾고자 하는 패턴이 들어있지 않은 줄만 표기 -w : 단어 단위로 찾기 (온전하게, 앞 뒤로 공백, 특수문자 등이 위치) 정규화표현식 - 검색에 사용되는 패턴 - vi, grep, sed, awk 등 텍스트를 다루는 다양한 도구에서 사용 - /RE/ : vi, sed, awk - 'RE' : grep 정규화표현식 주요 패턴 - ^[pattern] : 패턴의 모양으로 시작하는 라인만 검색 (ex. '^root') - [pattern]$ : 패턴의 모양으로 줄이 끝나는 라인만 검색 (ex. 'root$') - \\ : 단어 단위의 시작과 끝을 나타내는 패턴 (ex. '\\<hello') ",
    "url": "/docs/daily-learning-log/20210329.html",
    "relUrl": "/docs/daily-learning-log/20210329.html"
  },"8": {
    "doc": "2021-03-30",
    "title": "정규화표현식 주요 패턴",
    "content": "- . : 한 글자, 영문자(대/소), 숫자, 특수문자, 공백(스페이스, 탭) (ex. '…….' : 어떤 글자든지 총 7글자 - [pattern]* : 패턴이 0번 이상 반복 - a* : '', 'a', 'aa', 'aaa', 'aaaaaaaaa', … - .* : '', '.', '..', '…', …. : 아무거나, 모든 문자들 (ex. semanage fcontext -a -t [타입] '/wwwroot(/.*)?' ) - [문자들의 집합] : 집합에 포함된 글자들 중 한글자 - [abc] : a, b, c 중 한 글자 - [a-z] : 소문자 중 한 글자 - [0-9] : 숫자 중 한 글자 - [a-z0-9] : 소문자, 숫자 중 한 글자 - [Nn]ice : Nice 혹은 nice - [^문자들의 집합] : 집합에 포함되지 않은 글자들 중 한 글자 - [^abc] : a, b, c를 제외한 글자들 중 한 글자 - [^0-9] : 숫자가 아닌 한 글자 - \\ : Escape Sequence. 메타문자를 일반특수문자로 변환 ",
    "url": "/docs/daily-learning-log/20210330.html",
    "relUrl": "/docs/daily-learning-log/20210330.html"
  },"9": {
    "doc": "2021-03-30",
    "title": "grep 연습",
    "content": "- n 글자로 시작하는 라인을 찾기 - grep '^n' datafile - 4로 끝나는 라인을 찾기 - grep '4$' datafile - grep TB Savage datafile 해보기 - TB를 Savage 파일과 datafile 파일에서 검색한다는 의미 - grep 'TB Savage' datafile 해보기 - TB Savage를 datafile 파일에서 검색한다는 의미 - 숫자 5 뒤에 점(.)이 들어있는 라인을 찾기 - grep '5\\.' datafile - 점 뒤에 숫자 5가 들어있는 라인을 찾기 - grep '\\.5' datafile - w 또는 e로 시작하는 라인을 찾기 - grep '^[we]' datafile - M이 포함되어 있지 않은 라인을 찾기 - grep -v 'M' datafile - grep '^[^M]*$' dafafile - 참고로, grep '[^M]' datafile 은 M이 아닌 한 글자가 포함되어 있는 라인을 찾는다는 의미라서 부적합 - 대문자 두 글자 뒤 공백 한 글자. 다시 대문자 한 글자가 들어있는 라인을 찾기 - grep '[A-Z][A-Z] [A-Z]' datafile : 공백 한 글자를 스페이스로만 인식함 (탭은 해당되지 않음) - grep '[[:upper:]][[:upper:]][::space:]][[:upper:]]' datafile - [[::]]와 같은 특수 정규표현식은 아래 링크 참조 - https://support.google.com/a/answer/1371415?hl=ko - s가 한 글자 이상 반복되는 라인을 찾기 - grep 'ss*' datafile ",
    "url": "/docs/daily-learning-log/20210330.html",
    "relUrl": "/docs/daily-learning-log/20210330.html"
  },"10": {
    "doc": "2021-03-30",
    "title": "확장 정규화 표현식\t",
    "content": "- 확장 정규화 표현식은 grep에서는 사용불가하며, egrep에서 사용 가능!! - egrep : 확장 정규화 표현식 사용, grep -E와 동일 - fgrep : 정규화 표현식을 사용하지 않음 (fixed grep), 패턴을 일반 특수문자로 처리, grep -F와 동일 - ( ) : 패턴이 적용되는 부분을 묶어주기 - [pattern]+ : 패턴이 1번 이상 반복 (ex. ss* = s+ ) - [pattern]? : 패턴이 없거나, 1번 포함 - abc? : ab, abc (c에만 ?가 적용됨) - (abc)? : abc, 아무것도 없음 - ex. semanage fcontext -a -t [타입] '/wwwroot(/.*)?' - [pattern1]\\|[pattern2] : or, 즉, 패턴 1 또는 패턴 2 (ex. [Nn]ice = (N\\|n)ice ) - [pattern]{ } : 패턴의 반복 횟수 지정 - [pattern]{n} : 패턴 n번 반복 - [pattern]{n,m} : 패턴이 n번 이상 m번 이하 반복 - [pattern]{n,} : 패턴이 n번 이상 반복 - [pattern]{,m} : 패턴이 m번 이하 반복 ",
    "url": "/docs/daily-learning-log/20210330.html",
    "relUrl": "/docs/daily-learning-log/20210330.html"
  },"11": {
    "doc": "2021-03-30",
    "title": "egrep 연습\t",
    "content": "- NW 또는 EA 패턴을 검색 - egrep '(NW\\|EA)' datafile - 숫자 3이 1번 이상 반복 - egrep '3+' datafile - 2.x 또는 2x 패턴이 들어있는 라인 - egrep '2\\.?[0-9]' datafile - no 패턴이 1번 이상 반복되는 라인 - egrep '(no)+' datafile - Sh 또는 Su 라는 패턴이 들어있는 라인 - grep 'S[hu]' datafile - egrep 'S(h\\|u)' datafile - egrep '(Sh\\|Su)' datafile ",
    "url": "/docs/daily-learning-log/20210330.html",
    "relUrl": "/docs/daily-learning-log/20210330.html"
  },"12": {
    "doc": "2021-03-30",
    "title": "정규화표현식 개인실습\t",
    "content": "- San을 포함하고 있는 모든 줄을 출력하시오 - grep 'San' databook - 사람의 이름이 J로 시작하는 모든 줄을 출력하시오 - grep '^J' databook - 700으로 끝나는 모든 줄을 출력하시오 - grep '700$' databook - 834를 포함하지 않는 모든 줄을 출력하시오 - grep -v '834' databook - 생일이 12월인 모든 줄을 출력하시오 - grep ':12/' databook - 전화번호의 지역코드가 408인 모든 줄을 출력하시오 - grep ':408-' databook - 대문자 하나, 이어서 4개의 소문자, 콤마, 스페이스에 하나의 대문자를 초함하는 줄을 출력하시오 - grep '[A-Z][a-z]{4}, [A-Z]' databook - 성이 K나 k로 시작하는 모든 줄을 출력하시오 - grep ' [Kk][a-z]*:' databook - 급여가 6자리인 줄을 줄 번호와 함께 출력하시오 - grep ':[0-9]{6}$' databook - Lincoln이나 lincoln을 포함하고 있는 줄을 출력하시오 - grep '[Ll]incoln' databook - ID@도메인 형태로 이루어진 e-mail을 검색할 수 있는 정규식을 작성하시오 (corg) - egrep '[a-z][a-z0-9]*@[a-z][a-z0-9]*\\.(com\\|net\\|org)' test.txt - 핸드폰 번호를 검색할 수 있는 정규식을 작성하시오 - egrep '^01[016789]-[1-9][0-9]{2,3}-[0-9]{4}$' test.txt - IP주소를 검색할 수 있는 정규식을 작성하시오 - egrep '^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$' test.txt ",
    "url": "/docs/daily-learning-log/20210330.html",
    "relUrl": "/docs/daily-learning-log/20210330.html"
  },"13": {
    "doc": "2021-03-30",
    "title": "2021-03-30",
    "content": " ",
    "url": "/docs/daily-learning-log/20210330.html",
    "relUrl": "/docs/daily-learning-log/20210330.html"
  },"14": {
    "doc": "2021-03-31",
    "title": "sed (Stream Editor)\t\t",
    "content": "- vi, gedit, nano : file editor // sed는 stream editor로 file editor와는 다름 - interactive 기능이 없음 : 비대화형 에디터 - 파일을 수정해도 수정 내용이 반영되지 않음 : -I 옵션을 사용해야 파일에 저장 - 쉘 프로그래밍에서 많이 사용 - line 단위 처리 - vi 편집기와 유사 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"15": {
    "doc": "2021-03-31",
    "title": "pattern space\t\t",
    "content": "- sed는 텍스트를 라인 단위로 처리 - 처리를 하기 위해 텍스트 데이터를 가져와서 가공하는 공간 - 처리가 끝난 텍스트 데이터는 화면으로 출력 - 처리가 완료된 텍스트 데이터를 패턴 스페이스에서 제거됨 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"16": {
    "doc": "2021-03-31",
    "title": "sed 실행 형식\t\t",
    "content": "- sed [옵션] '명령어' 대상 : 특정 범위를 지정하지 않고 전체 라인에 적용 - sed [옵션] '패턴 명령어' 대상 : 패턴 명령어 = /패턴/ - ex. Sed -n '/1/p' number.txt : 1이 들어가는 곳을 출력 - sed [옵션] '범위 명령어' 대상 : 범위 명령어 = 라인(주소) : ~부터 ~까지 - 범위 예 : 라인 ; 라인, 라인 ; /패턴/,/패턴/ ; /패턴/,주소 ; 주소,/패턴/ - ex. sed '5q' number.txt : 5번째 줄까지 출력 - ex. sed -n '3,5p' number.txt : 3번째 줄부터 5번째 줄까지 출력 - ex. sed -n '/3/,/5/p' number.txt : 3이 나오는 곳부터 5가 나오는 곳까지 출력 - ex. sed -n '3,/5/p' number.txt : 3번째 줄부터 5가 나오는 곳까지 출력 - 참고 : $는 마지막 줄을 의미 (ex. Sed '6,$d' number.txt : 6번째줄부터 마지막 줄까지 삭제 ; 1~5출력) ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"17": {
    "doc": "2021-03-31",
    "title": "sed 명령어\t\t",
    "content": "- p : print 출력 - d : delete 삭제 - s : substitute 교체. 텍스트 데이터 바꾸기. Vi 편집기에서 사용하는 방식과 동일 - s/찾을패턴/바꿀내용/ : 라인에서 첫 번째 확인된 패턴만 교체 - s/찾을패턴/바꿀내용/g : 라인 내 패턴을 전체 교체 - append기능으로 쓰기 : 바꿀내용 맨 앞에 &를 추가 ; 현재 라인의 내용 뒤에 추가 - q : quit 종료 - a : 대상 아래줄에 라인 추가, 여러 줄 가능 - ex. sed '3 a\\\\(enter누르고)Hello World' number.txt : 3번째 줄 아래에 Hello World 추가 - ex. sed '3 aHello World' number.txt도 가능하지만 가독성이 떨어짐 - I : 대상 윗 줄에 라인 추가, 여러 줄 가능 - ex. sed '3,5 i\\\\(enter)Hello World' number.txt : 3번째부터 5번째줄 각각 위에 Hello World 추가 - c : change 지정된 라인을 변경 : 지정된 범위를 모두 삭제하고 새 내용으로 대체 됨 - ex. sed '3,5 c\\\\(enter)me' number.txt : 3번째부터 5번째줄 삭제되고 새로운 3번째 줄로 me가 들어감 ; me 다음 6이 나오게 됨 - ex. sed '3,5 c\\\\(enter)me\\\\(enter)me\\\\(enter)me' number.txt : 3번째부터 5번째 줄 삭제되고 me가 3줄 추가됨 - r : 파일에 있는 내용을 읽어와서 a 형태로 추가 - ex. sed '3r title.txt' number.txt : 3번째 줄 밑에 title.txt 내용 추가 - w : 파일에 기록 - ex. sed '3,5w text.txt' number.txt : 3번째줄부터 5번째 줄까지를 text.txt파일에 기록(파일 없을 시 생성됨) - ex. sed '1w number.txt' number.txt : number 파일에 첫 번째 줄만 남기라는 뜻 같지만, 동작 특성상 그냥 빈 파일이 됨 - w 동작 특성 상 기록되는 파일이 빈파일이 되는 듯 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"18": {
    "doc": "2021-03-31",
    "title": "sed 옵션\t\t",
    "content": "- -n : 패턴스페이스에서 처리한 라인의 기본 출력 억제, 보통 p와 함께 사용 - /p만 쓰면 데이터 처리가 진행된 라인은 두 번, 처리 안 한 라인은 한 번 출력함 - -e : 다중 편집 실행 : ex. sed -e -e ... - 앞부터 순서대로 실행내용 하나를 전부 수행하고 다음 실행내용을 전부 수행하는 방식 - 따라서 앞 단계의 실행내용이 뒷 단계의 실행내용에 영향을 줄 수 있음 - -f : 스크립트 형태로 편집할 내용을 불러오기 - sed 명령어에서 ' ' 내부에 들어가는 내용을 스크립트에 작성 - 여러 명령을 한꺼번에 집어넣기 가능 - 스크립트 내부에 내용 작성시 ' ' 기호는 제외 - 스크립트 끝부분에 불필요한 공백이 있을 경우 에러가 날 수 있음 - 한 줄에 여러 명령어를 함께 사용할 수 있음 ( ; 기호 사용) - 주석 사용 가능 : # 기호가 맨 앞에 있을 경우 주석 처리 - -r : 확장 정규화 표현식 사용 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"19": {
    "doc": "2021-03-31",
    "title": "sed 종합실습 (databook)\t\t",
    "content": "```js - Jon의 이름을 Jonathan으로 교체하시오 - sed -n 's/^Jon/Jonathan/p' databook - 처음 세 행을 삭제하시오 - sed '1,3d' databook - Lane이 포함된 행을 삭제하시오 - sed '/Lane/d' databook - 생일이 November나 December인 사람들의 행을 출력하시오 - sed -n '/:1[12]\\//p' databook - sed -n -e '/:11\\//p' -n -e '/:12\\//p' databook - Fred로 시작하는 행의 끝에 세 개의 별표(*)를 붙이시오 - sed -n '/Fred/s/.*$/&***/p' databook - sed -n '/Fred/p' databook \\| sed 's/.*$/&***/' - Popeye의 생일을 11/14/46으로 교체하시오 - sed -n '/Popeye/ s/:[0-9]*\\/[0-9]*\\/[0-9]*:/:11\\/14\\/46:/p' databook - sed -r -n ‘/Popeye/ s/:1?[0-9]\\/[123]?[0-9]\\/[0-9][0-9]:/:11\\/14\\/46:/p’ databook : 검색 쪽 월 표현에 0이 나올 수 있음 - 빈 행을 삭제하시오 - sed '/^$/d' databook - sed '/^[[:space:]]$/d' databook - 아래와 같은 sed 스크립트를 작성하시오 - 첫 줄에 Personal File 제목 삽입 - San Francisco에 거주하는 사람을 제거 - 마지막 줄에 THE END 추가 - sedscript 작성 # This is sed script 1i\\ Personal File /San Francisco/d $a\\ THE END - sed -f sedscript databook ``` ------------------------------------------------------- ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"20": {
    "doc": "2021-03-31",
    "title": "awk programing\t",
    "content": "구분자(Delimiter) : 텍스트 데이터에서 필드(Field)를 나누는 기호 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"21": {
    "doc": "2021-03-31",
    "title": "awk\t",
    "content": "- 만든 사람들의 이름 첫 글자를 따서 awk - awk 도구는 유닉스 용으로 만들어진 도구 - awk는 이후 new awk로 발전 - gawk : GNU awk = nawk (GNU : GNU's Not Unix) - 데이터 조작, 리포트 생성 등을 지원하는 도구 - awk 명령어 내에서 프로그래밍 기능 지원 - 레코드 단위의 처리를 수행 ; 기본적으로 각 줄을 한 레코드로 처리 - 즉, 레코드를 구분하는 구분자가 개행문자라는 뜻 - 구분자 변경 가능 - 레코드 내의 데이터는 필드 단위로 처리 가능 - 정규화 표현식 등을 사용할 수 있음 - grep, sed 등과 사용법이 유사하며 비슷한 기능을 가지고 있음 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"22": {
    "doc": "2021-03-31",
    "title": "용어\t",
    "content": "- 레코드 : 한 번에 처리되는 데이터의 단위. 기본적으로 한 줄 단위 - 필드 : 레코드 내의 데이터를 구분하는 단위 : 기본적으로 공백을 구분자로 사용 - 레코드 구분자 : RS(Record Separator), awk 내에서 RS 변수가 레코드 구분자를 저장 - 필드 구분자 : FS(Field Separator), awk 내에서 FS 변수가 필드 구분자를 저장 - ORS : Output RS ; 출력시 레코드 사이에 삽입되는 값 ; 기본으로 개행, 변수값을 변경하여 수정 - OFS : Output FS ; 출력 형식 지정시 ',' 기호를 통해 사용 가능 ; 기본으로 공백, 변수값을 변경하여 수정 - NF : Number of Field, 레코드를 읽어올 때 필드 구분자에 의해 분리된 필드의 개수 - NR : Number of Record, 현재 처리중인 레코드의 번호 - $0 : 전체 필드 데이터, 각 필드 사이에 OFS를 삽입하여 출력 - $1~ : 각 위치의 필드 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"23": {
    "doc": "2021-03-31",
    "title": "실행 형식\t",
    "content": "- awk [옵션] '/패턴/' : grep과 동일한 동작 - awk [옵션] '{ 명령 }' : 대상 파일의 각 레코드 별로 명령 실행 - awk [옵션] '/패턴/ {명령}' : 패턴에 해당하는 레코드에 대해 명령 실행 ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"24": {
    "doc": "2021-03-31",
    "title": "명령\t",
    "content": "- print : 데이터를 사용자가 지정한 형식으로 출력 옵션 - -F : FS 지정 - ex. awk -F: '{print $1}' sample.txt ; -F 뒤에 공백 있어도 되고 없어도 됨 - awk -F : '/nologin/ {print $1}' sample.txt ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"25": {
    "doc": "2021-03-31",
    "title": "2021-03-31",
    "content": " ",
    "url": "/docs/daily-learning-log/20210331.html",
    "relUrl": "/docs/daily-learning-log/20210331.html"
  },"26": {
    "doc": "2021-04-01",
    "title": " awk 계속 ",
    "content": " ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"27": {
    "doc": "2021-04-01",
    "title": "옵션",
    "content": "- -F : FS 지정 - ex. awk -F: '{print $1}' sample.txt ; -F 뒤에 공백 있어도 되고 없어도 됨 - awk -F : '/nologin/ {print $1}' sample.txt - 구분자가 여러가지인 경우 : -F'[구분자기호들]' (ex. awk -F'[:,]' '{print $1,$2,$3}' test.txt) ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"28": {
    "doc": "2021-04-01",
    "title": "명령",
    "content": "- print : 데이터를 사용자가 지정한 형식으로 출력 - 사용자가 입력한 모양대로 출력 생성 - $1, $2 등 필드를 지정하여 출력 가능 - 문자열 삽입 : \" \" - 내부에서 ',' 기호 사용시 자동으로 OFS 삽입 - 일부 특수한 용도의 문자 사용 가능 - \\b : 백스페이스 ; 커서를 앞으로 한 칸 이동 - \\n : new line ; 개행 - \\r : Carriage Return ; 커서가 라인의 맨 앞으로 이동 - \\a : Beep ; 소리 발생 - \\t : Tab 삽입 - \\047 : ' 기호 ; 숫자 변경시 다른 특수문자(코드값기준) - printf : print + format(출력형식) ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"29": {
    "doc": "2021-04-01",
    "title": "패턴 활용",
    "content": "- Match 연산자 : ~ - ~ : 특정 필드가 정규화 표현식을 만족하는지 확인 - awk -F: '$1 ~ /root/' /etc/passwd - !~ : 특정 필드가 정규화 표현식을 만족하지 않을 경우 - 비교연산자 >, =, 80 {print $1}' test.txt - awk -F: '$1 == \"root\"' /etc/passwd : 1번 필드가 root인 경우 - awk -F: '$1 ~ /root/' /etc/passwd : 1번 필드에 root 패턴이 있는 경우 - awk -F: '$1 ~ /^root$/' /etc/passwd : 1번 필드가 ^root$를 만족하는 경우 (==와 같은 의미로 해석됨) - 논리연산자 : &&, || ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"30": {
    "doc": "2021-04-01",
    "title": "출력시 데이터 변경\t",
    "content": "- 사칙연산 : +, -, *, /, % - awk -F'[:,]' '$2>80 {print $1, $2+10}' test.txt - awk -F'[:,]' '$2>80 {print $1, $2-10}' test.txt - awk -F'[:,]' '$2>80 {print $1, $2*10}' test.txt - awk -F'[:,]' '$2>80 {print $1, $2/10}' test.txt - awk -F'[:,]' '$2>80 {print $1, $2%3}' test.txt - 가산, 감산 : +=, -= - awk -F'[:,]' '$2>80 {print $1, $2+=10}' test.txt - awk -F'[:,]' '$2>80 {print $1, $2-=10}' test.txt - awk -F'[:,]' '$2>80 {$2+=10; print $1, $2}' test.txt - 문자열 값 변경 : = - awk -F'[:,]' '$2>80 {print $1=\"me\", $2}' test.txt - 선택적 데이터 출력 : '{print ( A ? B : C )}' : A를 검사해서 참이면 B 거짓이면 C 출력 - awk -F'[:,]' '{ print $1, ( $2>80?\"Pass\":\"Not Pass\")}' test.txt ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"31": {
    "doc": "2021-04-01",
    "title": "실습 (donors 파일)\t",
    "content": "- 전화번호를 모두 출력하세요 - awk -F: '{ print $2}' donors - Dan의 전화번호를 출력하세요 - awk -F: '/Dan/ { print $2}' donors - awk -F: '$1 ~ /Dan/ { print $2}' donors - Susan의 성(family name)과 전화번호를 출력하세요 - awk -F'[: ]' '$1==\"Susan\" { print $2,$3,$4 }' donors - awk -F'[: ]' '$1 ~ /Susan/ { print $2,$3,$4}' donors - C나 E로 시작하는 이름을 출력하세요 - awk -F'[: ]' '$1 ~ /^[CE]/ { print $1}' donors - 지역번호가 916인 사람들의 이름을 출력하세요 - awk -F'[: ]' '$3 ~ /^\\(916\\)$/ { print $1}' donors - Mike의 기부금을 출력하세요. 액수는 달러 기호($)로 시작해야 합니다. (예: $250, $100) - awk -F: '$1 ~ /Mike/ { print \"$\"$3\", $\"$4\", $\"$5}' donors 변수의 초기화 : 변수를 선언할 때 기본값 입력 - awk에서는 변수를 사용하면 즉시 생성되고 초기화 ; 수치는 0 ; 문자는 \"\" ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"32": {
    "doc": "2021-04-01",
    "title": "BEGIN\t\t\t\t",
    "content": "- awk 명령어 시작 시 한 번만 수행되는 내용 - 블록 형태로 작성 - 변수의 선언 및 초기화 - 기본 내장 변수(FS, OFS, RS, ORS)값을 변경할 때 사용 - 헤더, 타이틀 등을 출력할 때 사용 ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"33": {
    "doc": "2021-04-01",
    "title": "END",
    "content": "- 모든 레코드에 대한 처리가 완료된 이후 1번만 실행 - 결과치를 출력하기 위한 용도로 사용 - 푸터(footer) 아래쪽에 들어갈 내용 출력 시 사용 ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"34": {
    "doc": "2021-04-01",
    "title": "BEGIN, END 사용 예시\t",
    "content": "- awk 'BEGIN{ FS=\"[:,]\"; OFS=\"\\t\"; KOR=100; print \"KOR Score\\n=========\"}{ KOR+=$2; print $1,$2 } END{print \"========\\nKOR total: \"KOR\"\\n=========\"}' test.txt ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"35": {
    "doc": "2021-04-01",
    "title": "awk script\t\t\t\t",
    "content": "- 실행할 내용 중 ' ' 안에 들어갈 내용을 스크립트로 작성 (sed와 동일) - BEGIN, ACTION, END를 각 줄로 구분하여 처리 - 세미콜론 부분은 줄 바꿈으로 치환 가능 - 예시 스크립트 ```js BEGIN{ FS=\"[:,]\"        OFS=\"\\t\"        KOR=100        print \"KOR Score\\n=========\"} { KOR+=$2; print NR, $1,$2 } END{ print \"========\\nKOR total: \"KOR\"\\n=========\"} ``` - 예시 스크립트 사용 : awk -f awkscript test.txt ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"36": {
    "doc": "2021-04-01",
    "title": "awk script 실습 예제\t\t",
    "content": "```js - 다음과 같은 형식으로 출력하시오 Donor List ------------------------------------------------------------------------- Name Phone Jan Feb Mar AVG ------------------------------------------------------------------------- Mike Harrington (510) 548-1278 250 100 175 175.00 Christian Dobbins (408) 538-2358 155 90 201 148.67 Susan Dalsass (206) 654-6279 250 60 50 120.00 .... ------------------------------------------------------------------------- Summary ------------------------------------------------------------------------- Total donate : $6137 Avg : $511 ------------------------------------------------------------------------- ``` - print만 사용 ( 이름이 긴 사람들 때문에 칸이 어긋남 ) ```js BEGIN{ FS=\":\" OFS=\"\\t\" TOTAL=0 PERTOTAL=0 print \" Donor List\" print \"-------------------------------------------------------------------------\" print \"Name Phone Jan Feb Mar\" print \"-------------------------------------------------------------------------\" } { PERTOTAL=$3+$4+$5 TOTAL+=PERTOTAL print $1\"\\t\"$2,$3,$4,$5,PERTOTAL/3 } END{ print \"-------------------------------------------------------------------------\" print \"Summary\" print \"-------------------------------------------------------------------------\" print \"Total donate : $\"TOTAL print \"Avg : $\"TOTAL/NR print \"-------------------------------------------------------------------------\" } ``` - printf 사용 ```js BEGIN{ FS=\":\" OFS=\"\\t\" TOTAL=0 PERTOTAL=0 print \" Donor List\" print \"-------------------------------------------------------------------------\" printf \"%-20sPhone Jan Feb Mar AVG\\n\",\"Name\" print \"-------------------------------------------------------------------------\" } { PERTOTAL=$3+$4+$5 TOTAL+=PERTOTAL printf \"%-20s%s\\t%3d\\t%3d\\t%3d\\t%.2f\\n\",$1,$2,$3,$4,$5,PERTOTAL/3 } END{ print \"-------------------------------------------------------------------------\" print \"Summary\" print \"-------------------------------------------------------------------------\" print \"Total donate : $\"TOTAL print \"Avg : $\"TOTAL/NR print \"-------------------------------------------------------------------------\" } ``` ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"37": {
    "doc": "2021-04-01",
    "title": "조건문과 반복문",
    "content": " ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"38": {
    "doc": "2021-04-01",
    "title": "조건문 개요\t\t\t",
    "content": "- 조건에 따라 수행할 동작을 지정 - if : 조건이 맞으면 실행, 아니면 패스 - if~else : 조건이 맞으면 if 아래를 실행, 조건이 틀리면 else 아래를 실행 - if~else if~else : 조건이 여러 개, if, else if, else임 ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"39": {
    "doc": "2021-04-01",
    "title": "조건문의 문법 : if, then, fi\t\t\t",
    "content": "- 유형 1 ```js if (조건) then (if 실행할 내용) fi ``` - 유형 2 ```js if (조건) then (if 실행할 내용) else (else 실행할 내용) fi ``` - 유형 3 ```js if (조건1) then (if 조건1에 따라 실행할 내용) elif (조건2) then (elif 조건2에 따라 실행할 내용) elif (조건3) then (elif 조건3에 따라 실행할 내용) … else (모든 조건을 만족하지 않을 경우 실행할 내용) fi ``` - case = if~elif~else와 유사한 동작 ```js case 변수명 in 값1) 실행내용1 ;; 값2) 실행내용2 ;; 값3) 실행내용3 ;; *) 실행내용4 esac ``` ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"40": {
    "doc": "2021-04-01",
    "title": "쉘 프로그래밍의 조건문에서의 '조건'\t\t\t",
    "content": "- 명령의 실행 결과가 if의 조건으로 사용됨 : 종료상태 (Exit Status) - 정상종료 : 0 (true) - 비정상종료 : 0이 아닌 모든 값 (false) - /usr/bin/true, /usr/bin/false : 다른 역할은 하지 않으면서 종료상태만 변경 - ‘ : ’ : true 와 같은 역할 - 수치비교, 문자, 문자열비교 : test - 수치비교 - == : equal; INT1 -eq INT2 - != : not equal; INT1 -ne INT2 - > : greater than ; INT1 -gt INT2 - = : greater or equal ; INT1 -ge INT2 - 문자열2 ]] : 문자열1이 문자열2보다 ASCII 값이 크면 참 - 마찬가지로, let을 사용하여 수치비교 가능 : (( )) - (( 변수1 > 숫자 )) : 변수1이 숫자보다 크면 참 - (( 변수1 = 변수2 + 변수3 )) : 변수를 사용한 계산 가능 - 파일관련 조건 확인 : [옵션] [파일명] - -b : 블록 장치인지 - -c : 캐릭터 장치인지 - -d : 디렉토리인지 - -e : 파일이 존재하는지 - -f : 일반 파일인지 - -r : test를 수행하는 사용자가 파일의 읽기 권한이 있는지 - -w : test를 수행하는 사용자가 파일의 쓰기 권한이 있는지 - -x : test를 수행하는 사용자가 파일의 실행 권한이 있는지 - -u : SetUID가 설정되어 있는지 - -g : SetGID가 설정되어 있는지 - -k : StickyBit가 설정되어 있는지 - test 사용시 조건의 논리합/논리곱 - and : [ 조건1 -a 조건2 ] 혹은 [[ 조건1 && 조건2 ]] - or : [ 조건1 -o 조건2 ] 혹은 [[ 조건1 \\|\\| 조건2 ]] ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"41": {
    "doc": "2021-04-01",
    "title": "2021-04-01",
    "content": " ",
    "url": "/docs/daily-learning-log/20210401.html",
    "relUrl": "/docs/daily-learning-log/20210401.html"
  },"42": {
    "doc": "2021-04-05",
    "title": "Ansible",
    "content": " ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"43": {
    "doc": "2021-04-05",
    "title": "Ansible 실습 환경",
    "content": "- Control Node : CentOS 7.8 ova IP : 192.168.100.10/24 gateway : 192.168.100.2 dns : 192.168.100.2 ```js # nmcli connection add con-name static ifname ens33 type ethernet ipv4.addresses 192.168.100.10/24 ipv4.gateway 192.168.100.2 ipv4.dns 192.168.100.2 ipv4.method manual # nmcli connection up static # nmcli connection show # nmcli connection delete ens33 # ip a s ens33 # ping 192.168.100.21 # ping 192.168.100.22 # hostnamectl set-hostname control.example.local ``` - Managed hosts : CentOS 7.8 ova ; multi-user.target, 메모리, CPU 확인 IP : 192.168.100.21,22/24 gateway : 192.168.100.2 dns : 192.168.100.2 ```js # nmcli connection add con-name static ifname ens33 type ethernet ipv4.addresses 192.168.100.21/24 ipv4.gateway 192.168.100.2 ipv4.dns 192.168.100.2 ipv4.method manual # nmcli connection up static # nmcli connection delete ens33 # systemctl set-default multi-user.target # reboot ``` ---------------------------------------- ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"44": {
    "doc": "2021-04-05",
    "title": "기존 시스템 관리 방식",
    "content": "- 수동관리. 직접 콘솔을 통해서 관리. 네트워크를 통한 접근 - 직접 관리 방식은 사용자에 의한 오류 발생 등의 가능성이 높음 - 수행 결과에 대한 검증 - 각자 다른 환경에 대한 일괄적인 구성이 어려움 - 유지관리 어려움 - 자동화된 관리의 필요성 : IaC ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"45": {
    "doc": "2021-04-05",
    "title": "IaC 개요",
    "content": "- Infrastructure as Code : 코드형 인프라 - 코드에 의하여 자동적으로 인프라를 구성하도록 하는 방식 - 인프라 자체에 대한 배포 - 구성 설정을 관리 - 클라우드 등과 결합하여 더 강력한 힘을 가지게 됨 ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"46": {
    "doc": "2021-04-05",
    "title": "IaC 특징",
    "content": "- 시스템이 자동으로 읽어서 처리할 수 있는 언어(Code)를 사용 - 상태에 대하여 이해를 하고, 변경사항을 반영할 수 있도록 구성 - 텍스트 형태의 파일로 구성되어 버전 관리가 용이 - 인적 오류 완화 ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"47": {
    "doc": "2021-04-05",
    "title": "Ansible",
    "content": "- 오픈소스 자동화 관리도구 플랫폼 - 상용화된 기능도 제공 : Ansible Tower - 구성관리의 포지션을 담당 - 일회성 명령, 플레이북(Playbook) 사용 - 플레이북은 YAML(YAML Ain't Markup Language) 문법을 사용 - Agentless(에이전트가 없음) ; SSH, Python이 필요 ; 관리하는 역할이 필요 없다는 얘기는 아님 - Idempotency : 멱등성 (연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질) 반복적으로 작업을 실행해도 이미 실행한 작업은 다시 수행하지 않음 ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"48": {
    "doc": "2021-04-05",
    "title": "Redhat 리눅스 관련 자격증",
    "content": "- RHCSA(RedHat Certified System Administrator) : 리눅스 기본 - RHCE(RedHat Certified Engineer) : 리눅스 고급관리 → Ansible로 바뀜 ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"49": {
    "doc": "2021-04-05",
    "title": "Ansible 아키텍처",
    "content": "- 제어 노드 (Control Node) - Ansible을 사용하여 Managed hosts를 관리하는 역할 - Ansible이 실제 설치되어야 하는 위치 - 프로젝트 파일 작성, 보관 - 관리 호스트 (Managed Host) - Ansible을 통해 관리되는 인프라 - 인벤토리(Inventory)를 사용하여 관리 호스트 목록을 제어 - 개별 호스트, 그룹 지정 가능 - 정적 인벤토리 / 동적 인벤토리 사용 가능 - 플레이북 - YAML 형태의 언어로 구성된 텍스트 파일 - 플레이북은 하나 이상의 플레이로 구성 - 플레이는 하나 이상의 작업(Tasks)로 구성 - 작업 - 모듈(Module)을 실행 - 거의 대부분의 모듈은 멱등성을 지원 (command, shell, raw 등은 제외) - 플레이북 내에서 작업 실행 중 실패시 나머지 작업이 중단 ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"50": {
    "doc": "2021-04-05",
    "title": "Ansible 권장 사용방식",
    "content": "- 복잡하지 않게 - 가독성을 좋게 - 선언적인 사고 : 모듈 내에서는 해당 모듈을 통해 갖추어야 할 상태를 정의 ------------------------------------------ ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"51": {
    "doc": "2021-04-05",
    "title": "Ansible 설치 (제어 노드)",
    "content": "- 제어노드는 유닉스/리눅스만 가능 (Windows는 안됨) - 파이썬 2.6 이상 또는 3버전 이상 필요 - ssh 명령 사용 가능 - CentOS 에서는 EPEL 레포지토리가 활성화되어 있어야 설치 가능 ```js # yum install epel-release # yum install ansible ``` ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"52": {
    "doc": "2021-04-05",
    "title": "관리노드 설정 확인",
    "content": "- 리눅스/유닉스/Windows/네트워크 장비 등을 사용 가능 - 리눅스/유닉스/네트워크장비 : SSH 연결 + Python (2.6 이상) - Windows : WinRM (Windows Remote Management) + PowerShell - SSH 연결 : 키 기반 인증 설정 ; key-gen을 이용해서 키를 호스트에 복사해서 ssh연결을 암호없이 사용 - 모듈 실행 시 암호 입력하는 식으로 하고싶으면 명령 맨 끝에 --ask-pass ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"53": {
    "doc": "2021-04-05",
    "title": "인벤토리 생성",
    "content": "- 인벤토리 파일은 INI 파일 형식 또는 YAML 형식으로 작성 (주로 INI) - [항목] 형태나 [키]=[값] 형태로 작성 - 호스트 그룹 사용시 [그룹이름] - 기본적으로 지정되어 있는 그룹 - all : 인벤토리 내의 모든 호스트들을 중복을 제거하고 출력 - ungrouped : 특정 그룹에 속하지 않은 호스트 - 인벤토리 확인 : --list-hosts - ansible -i [인벤토리] --list-hosts - 인벤토리에 호스트 지정시 범위 사용 가능 - server1.example.local ~ server10.example.local 호스트 등록시 : server[1:10].example.local - 숫자는 [시작:마지막:iteration]으로 지정하며 [01:10]과 같은 형식도 가능 - 알파벳도 가능 [a:f] ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"54": {
    "doc": "2021-04-05",
    "title": "Ad-hoc 명령 실행",
    "content": "- ansible 명령을 사용하여 단일 모듈을 대상에 대하여 실행 - 명령어 : ansible -m [사용할 모듈] -a [모듈 사용시 필요한 argument] -i [인벤토리] ```js # ansible -m ping -i inventory managed1.example.local #ping모듈은 argument 필요 없음 # ansible -i inventory --list-hosts all #all 그룹에게 실행하기 ``` ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"55": {
    "doc": "2021-04-05",
    "title": "Ansible 주요 파일",
    "content": "- /etc/ansible/hosts : 기본 Ansible 인벤토리 파일 - /etc/ansible/ansible.cfg : 기본 Ansible 설정 파일 (config) ; 이 파일은 우선 순위가 높지 않음 - Ansible 설정파일 우선순위 - ANSIBLE_CONFIG : 환경변수로 지정한 경로의 파일 사용. 유연한 관리 - ./ansible.cfg : ansible 명령을 실행하고 있는 working directory 내 설정파일 - ~/.ansible.cfg : 사용자에게 적용되는 Ansible 설정 파일 - /etc/ansible/ansible.cfg - 사용중인 설정파일 확인 방법 - ansible --version : 현재 위치에서 ansible 명령 사용시 쓰는 설정파일 확인 - ansible-config - view : 설정파일 내용 출력 - dump : 전체 설정항목 값 출력 (노란색 : 설정파일에 의해 변경된 값) - Ansible 설정 파일 내 주요 항목 - [defaults] : Ansible 동작의 기본 설정. ex) 인벤토리 등 - inventory : 인벤토리 파일/디렉토리의 경로 - 기본값 : /etc/ansible/hosts - remote_user : 관리 호스트(managed host)가 접근시 사용할 계정 ; root는 권장하지 않음 - 기본값 : 사용자이름 - ask_pass : ansible 실행 시 패스워드를 물어볼지 여부 (yes/no/true/false) ; 연결을 위함 - 기본값 : False - [privilege_escalation] : 권한 상승 - become : 관리자 권한 상승 여부 (Y/N/T/F) - 기본값 : False - become_method : 관리자 권한 상승 방법 (sudo/su) - 기본값 : sudo - become_user : 권한 상승시 변경할 사용자 (root) - 기본값 : root - become_ask_pass : 권한 상승시 필요한 암호 입력 여부 (Y/N/T/F) - 기본값 : False ```js - 샘플 cfg (/home/user/ansible/ansible.cfg) [defaults] inventory = ./inventory remote_user = user ask_pass = false [privilege_escalation] become = true become_method = sudo become_user = root become_ask_pass = true ``` ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"56": {
    "doc": "2021-04-05",
    "title": "테스트 명령",
    "content": "- testuser 존재하게 만들기 ```js $ ansible -m user -a 'name=testuser state=present' all BECOME password: managed1.example.local | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"comment\": \"\", \"create_home\": true, \"group\": 1001, \"home\": \"/home/testuser\", \"name\": \"testuser\", \"shell\": \"/bin/bash\", \"state\": \"present\", \"system\": false, \"uid\": 1001 } managed2.example.local | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"comment\": \"\", \"create_home\": true, \"group\": 1001, \"home\": \"/home/testuser\", \"name\": \"testuser\", \"shell\": \"/bin/bash\", \"state\": \"present\", \"system\": false, \"uid\": 1001 } $ ansible -m user -a 'name=testuser state=present' all BECOME password: managed2.example.local | SUCCESS => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"append\": false, \"changed\": false, \"comment\": \"\", \"group\": 1001, \"home\": \"/home/testuser\", \"move_home\": false, \"name\": \"testuser\", \"shell\": \"/bin/bash\", \"state\": \"present\", \"uid\": 1001 } managed1.example.local | SUCCESS => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"append\": false, \"changed\": false, \"comment\": \"\", \"group\": 1001, \"home\": \"/home/testuser\", \"move_home\": false, \"name\": \"testuser\", \"shell\": \"/bin/bash\", \"state\": \"present\", \"uid\": 1001 } ``` - 다시 실행하면 changed=false가 됨 (이미 한 번 실행한 상태에서 또 실행해봤자 바뀌는 것이 없기 때문) - testuser 존재하지 않도록 만들기 ```js $ ansible -m user -a 'name=testuser state=absent' all BECOME password: managed2.example.local | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"force\": false, \"name\": \"testuser\", \"remove\": false, \"state\": \"absent\" } managed1.example.local | CHANGED => { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": true, \"force\": false, \"name\": \"testuser\", \"remove\": false, \"state\": \"absent\" } ``` ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"57": {
    "doc": "2021-04-05",
    "title": "Tip!!! 자동완성 (root계정으로 해야함!)",
    "content": "- ansible은 자동완성 기능이 없음 - 구글에서 ansible bash completion이라고 검색, 오픈 소스를 찾음 - .bash파일을 서버의 /etc/bash_completion.d 폴더에 저장 - 변경 적용하려면 # exec bash (현재 터미널에서 bash 재시작 명령) ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"58": {
    "doc": "2021-04-05",
    "title": "실습 환경 구성 내용 정리 - 강사님 ",
    "content": "Control node 1개, Managed host 2개를 import 기본 네트워크 및 호스트이름 설정 - Control node ```js $ sudo -i # nmcli connection add con-name static ifname ens33 type ethernet ipv4.addresses 192.168.100.10/24 ipv4.gateway 192.168.100.2 ipv4.dns 192.168.100.2 ipv4.method manual # nmcli connection up static # nmcli connection delete ens33 # hostnamectl set-hostname control.example.local ``` - Managed host 1 ```js $ sudo -i # nmcli connection add con-name static ifname ens33 type ethernet ipv4.addresses 192.168.100.21/24 ipv4.gateway 192.168.100.2 ipv4.dns 192.168.100.2 ipv4.method manual # nmcli connection up static # nmcli connection delete ens33 # systemctl set-default multi-user.target # hostnamectl set-hostname managed1.example.local # reboot ``` - Managed host 2 ```js $ sudo -i # nmcli connection add con-name static ifname ens33 type ethernet ipv4.addresses 192.168.100.22/24 ipv4.gateway 192.168.100.2 ipv4.dns 192.168.100.2 ipv4.method manual # nmcli connection up static # nmcli connection delete ens33 # systemctl set-default multi-user.target # hostnamectl set-hostname managed2.example.local # reboot ``` Control node의 /etc/hosts 파일을 수정 ```js 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 192.168.100.21 managed1 managed1.example.local 192.168.100.22 managed2 managed2.example.local ``` Managed host에 SSH 키 기반인증을 하기 위하여 필요한 키 생성 (반드시 Control node에서 실행) ```js user@control $ ssh-keygen 입력항목은 전부 기본값으로 설정 user@control $ ssh-copy-id user@managed1.example.local user@control $ ssh-copy-id user@managed2.example.local ``` 각 호스트에 키 기반 인증이 연결되는지 확인 ```js user@control $ ssh user@managed1.example.local user@control $ ssh user@managed2.example.local ``` Control node에 ansible 설치 (Managed 에는 설치할 필요 없음) ```js user@control $ sudo yum -y install epel-release user@control $ sudo yum -y install ansible ``` Ansible 설치 확인 ```js user@control $ ansible --version ``` (옵션) ansible bash completion 설치 ```js user@control $ sudo -i root@control # cd /etc/bash_completion.d/ root@control # wget https://raw.githubusercontent.com/dysosmus/ansible-completion/master/ansible-completion.bash root@control # exit user@control $ exec bash ``` ansible 실습용 디렉토리 작성 ```js user@control $ cd user@control $ mkdir ansible user@control $ cd ansible ``` 기본 인벤토리 파일 생성 ```js user@control $ cat > inventory managed1.example.local managed2.example.local ``` 기본 환경설정 파일 생성 ```js user@control $ cat > ansible.cfg [defaults] inventory = ./inventory remote_user = user ask_pass = false [privilege_escalation] become = true become_method = sudo become_user = root become_ask_pass =true ``` ansible 명령 동작 확인 ```js user@control $ ansible -m user -a ‘name=testuser state=present’ all ``` ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"59": {
    "doc": "2021-04-05",
    "title": "2021-04-05",
    "content": " ",
    "url": "/docs/daily-learning-log/20210405.html",
    "relUrl": "/docs/daily-learning-log/20210405.html"
  },"60": {
    "doc": "2021-04-06",
    "title": "Ansible 계속",
    "content": " ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"61": {
    "doc": "2021-04-06",
    "title": "Ansible을 통해 관리자 권한 사용",
    "content": "- sudo 패스워드 입력 없이 sudo 사용 가능 - sudoers 설정의 NOPASSWD 설정 - /etc/sudoers.d/ 파일에 - ALL=(ALL) NOPASSWD: ALL ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"62": {
    "doc": "2021-04-06",
    "title": "명령어에서 ansible.cfg 파일의 설정과 다른 설정을 사용",
    "content": "- 명령어 맨 끝에 원하는 설정 표기 - --inventory, -i : 인벤토리 재지정 - --user, -u : remote user 재지정 - --ask-pass, -k : ask_pass 활성화 - --become, -b : become 활성화 - --become-method : become_method 재지정 - --become-user : become_user 재지정 - --ask-become-pass, -K : become_ask_pass 재지정 ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"63": {
    "doc": "2021-04-06",
    "title": "Ansible 모듈 검색",
    "content": "- ansible docs 검색 - https://docs.ansible.com/ansible/2.9/ 내 module index 항목 참고 - ansible-doc 명령 사용 - ansible-doc -l : 전체 모듈 목록 확인 - ansible-doc [모듈이름] : 개별 모듈 확인 - options : 모듈 사용시 필요한 argument - = : 필수 항목 - - : 선택 항목 (일부 선택항목은 기본값이 지정되어 있으며 ansible-doc에 표기되어있음) - example 참고 - ansible-doc -l | grep [키워드] : 특정 키워드와 관련된 ansible 모듈 검색 ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"64": {
    "doc": "2021-04-06",
    "title": "command, shell, raw 모듈",
    "content": "- 대상 시스템에서 단순 명령 실행 형태로 동작 - raw - python이 없어도 사용 가능 - 일반적으로는 사용하지 않음 - python이 깔려있지 않은 managed host에 python 설치 등을 하기 위한 목적 정도로만 사용 - command - 쉘을 실행하지 않고 명령 수행 - shell - 쉘을 실행하고 쉘 내에서 명령 수행 - 비교 - 파일로 존재하는 명령어 실행시는 차이가 없음 - ansible -m shell -a hostname managed1.example.local - ansible -m command -a hostname managed1.example.local - 쉘 내장 명렁어, 또는 쉘 기능 사용시는 차이가 발생 - ansible -m shell -a set managed1.example.local - ansible -m command -a set managed1.example.local ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"65": {
    "doc": "2021-04-06",
    "title": "Playbook",
    "content": " ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"66": {
    "doc": "2021-04-06",
    "title": "Playbook",
    "content": "- Ansible로 실행할 내용을 작성하는 문서 = Code - ad-hoc 명령과 달리 여러 가지 수행할 내용을 하나의 플레이북에 저장 - 구조 ```js - 플레이북 파일 - 플레이(1개 이상) - 작업 - 모듈(1개 이상) ``` - YAML 문법을 사용하여 작성하여야 함 - 확장자를 .yaml 또는 .yml - --- : 문서의 시작을 의미하는 마커 - … : 문서의 마지막을 의미하는 마커 - 들여쓰기 구조로 작성 : Ansible에서는 일반적으로 공백 2칸으로 한 단계를 지정 - vi 편집기에서 yaml을 작성할 때 공백 기본값을 변경하여 편리하게 코드 작성하는 방법 - ~/.vimrc 파일 작성하기 ```js syntax on autocmd FileType yaml setlocal ts=2 sts=2 sw=2 et ai nu # et: expand tab. 탭 입력시 공백으로 변환 # ai : auto indent. 자동 들여쓰기 # nu : 줄 수 표시 ``` - 목록 사용 가능(리스트) - 목록의 아이템의 하나의 대시, 공백 뒤에 아이템 목록을 표시 - 목록의 아이템1 - 목록의 아이템2 - 목록의 아이템3 - ... - 각 항목의 값을 입력할 경우 ':' 뒤에 입력 - 반드시 항목의 이름 뒤에 붙여서 : 작성 - : 뒤에 공백 한 칸 추가 - 기본적으로 플레이북에 포함되는 항목 - play의 이름(설명): name 항목으로 플레이의 이름을 표시 - hosts: 플레이를 적용할 대상 - tasks: 이 플레이를 통해 실행할 작업의 목록 - 내부에는 작업의 목록이 표시 - name으로 작업에 대한 설명 추가 - 샘플 파일 (test.yaml) ```js --- - name: My first play hosts: managed1.example.local tasks: - name: user testuser must exist user: name: testuser state: present - name: ping test ping: ... ``` ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"67": {
    "doc": "2021-04-06",
    "title": "플레이북 실행",
    "content": "- ansible-playbook [옵션] - ansible 명령과 동일한 옵션 사용가능 : --become 등 - 플레이북 실행 시 구체적인 실행내용 확인 - -v : v의 개수를 1~4개 사용하여 구체적인 정도를 지정 - Gathering Facts : 플레이북 실행 시 자동으로 처음에 실행되는 대상 시스템 정보 수집단계 - Play Recap : 실행 통계. ok(정상), changed(변경), failed(실패) - --syntax-check : 플레이북 파일 내 구조적인 오류 탐지. 내용상의 결함은 찾지 못함 - -C, --check : 예행연습. 실제 대상에 변경을 가하지 않으면서 동작 여부 확인 ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"68": {
    "doc": "2021-04-06",
    "title": "다중 플레이",
    "content": "- 하나의 플레이북 내에 두 개 이상의 플레이를 지정 - 각 플레이는 동일한 들여쓰기 단계를 준수하여 작성 - 각 플레이의 구조는 동일하며, 플레이마다 각각 대상을 지정할 수 있음 (hosts) - 샘플 파일 (test.yaml) ```js --- - name: My first play hosts: managed1.example.local tasks: - name: user testuser must exist user: name: testuser state: present - name: My second play hosts: managed2.example.local tasks: - name: user testuser2 must exist user: name: testuser2 state: present ... ``` ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"69": {
    "doc": "2021-04-06",
    "title": "플레이북 내에서 플레이 별 설정",
    "content": "- 플레이 별로 개별적인 옵션을 지정 가능 (become, become_method, become_user, remote_user…) - 샘플 파일 (test.yaml) ```js --- - name: My first play hosts: managed1.example.local become: true tasks: - name: user testuser must exist user: name: testuser state: present - name: My second play hosts: managed2.example.local become: false tasks: - name: ping test ping: ... ``` ```js --- - name: My first play hosts: managed1.example.local tasks: - name: user testuser must exist user: name: testuser state: present become: true - name: user testuser must exist user: name: testuser2 state: present - name: My second play hosts: managed2.example.local become: false tasks: - name: ping test ping: ... ``` ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"70": {
    "doc": "2021-04-06",
    "title": "연습 - 웹서버 구성",
    "content": "- managed1, managed2 서버를 각각 웹 서버, DB 서버로 구성해 보자 - 각 서버에 필요한 패키지를 설치 - 서비스 구동 - 방화벽 설정 - inventory 구성 (/home/user/practice/inventory) ```js [webservers] managed1.example.local [dbservers] managed2.example.local [allservers:children] webservers dbservers ``` - ansible.cfg 구성 (/home/user/practice/ansible.cfg) ```js [defaults] inventory = ./inventory remote_user = user ask_pass = false [privilege_escalation] become = false become_method = sudo become_user = root become_ask_pass = false ``` - webservice.yaml 구성 ; prototype (/home/user/practice/webservice.yaml) ```js --- - name: webserver is ready hosts: webservers become: true tasks: - name: httpd package is installed yum: name: httpd state: latest - name: httpd service is enabled and started - name: firewall is opened - name: dbserver is ready hosts: dbserver become: true tasks: - name: mariadb package is installed yum: name: mariadb-server state: latest - name: mariadb service is enabled and started - name: firewall is opened ... ``` ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"71": {
    "doc": "2021-04-06",
    "title": "2021-04-06",
    "content": " ",
    "url": "/docs/daily-learning-log/20210406.html",
    "relUrl": "/docs/daily-learning-log/20210406.html"
  },"72": {
    "doc": "2021-04-07",
    "title": "Playbook",
    "content": "연습 - 웹서버 구성 - managed1, managed2 서버를 각각 웹 서버, DB 서버로 구성해 보자 - 각 서버에 필요한 패키지를 설치 - 서비스 구동 - 방화벽 설정 - inventory 구성 (/home/user/practice/inventory) ```js [webservers] managed1.example.local [dbservers] managed2.example.local [allservers:children] webservers dbservers ``` - ansible.cfg 구성 (/home/user/practice/ansible.cfg) ```js [defaults] inventory = ./inventory remote_user = user ask_pass = false [privilege_escalation] become = false become_method = sudo become_user = root become_ask_pass = false ``` - webservice.yaml 구성 ; prototype (/home/user/practice/webservice.yaml) ```js --- - name: webserver is ready hosts: webservers become: true tasks: - name: httpd package is installed yum: name: httpd state: latest - name: httpd service is enabled and started service: name: httpd enabled: true state: started - name: firewall is opened firewalld: service: http state: enabled permanent: true - name: dbserver is ready hosts: dbservers become: true tasks: - name: mariadb package is installed yum: name: mariadb-server state: latest - name: mariadb service is enabled and started service: name: mariadb state: started enabled: yes - name: firewall is opened firewalld: service: mysql state: enabled permanent: yes ... ``` - 실행 전 테스트 ```js $ ansible-playbook webservice.yaml --syntax-check $ ansible-playbook webservice.yaml --check ``` - 실행 후 확인 ```js $ ansible-playbook webservice.yaml ``` 변수(Variables) - 재사용 할 수 있는 값을 저장하기 위하여 사용 - ex. 설치할 패키지의 이름, 서비스의 이름, 추가할 파일의 경로, 인터넷 경로 주소 ... - 변수 이름 규칙 - 사용할 수 있는 글자 : 영문자(대소문자), 숫자, 밑줄 - 문자로 시작해야함 변수 적용 범위에 따른 변수의 위치 - 전역 범위 : 명령줄, Ansible 설정에서 변수를 지정 - ex. ansible-playbook -e “변수이름=변수값” - 플레이 : 플레이북의 구조에서 선언 - 플레이의 vars 예약어를 사용하여 변수 지정 ```js $ cat webservice.yaml --- - name: webserver is ready hosts: webservers become: true vars: package: httpd service: httpd firewall_svc: http ... ``` - 별도의 파일을 사용하여 변수 지정 : yaml 포맷으로 작성 ```js $ cat http.yaml package: httpd service: httpd firewall_svc: http ``` - 파일을 불러올 때에는 vars_files 예약어를 사용하여 변수가 들어있는 파일을 지정 ```js $ cat webservice.yaml --- - name: webserver is ready hosts: webservers become: true vars_files: - http.yml ... ``` - 호스트/그룹 : 인벤토리 내의 특정 호스트/그룹 - 인벤토리 내 특정 호스트에 대한 변수 설정 : 인벤토리 내 호스트 목록 뒤 ```js $ cat inventory [webservers] managed1.example.local service=httpd, package=httpd, firewall_svc=http ``` - 인벤토리 내 특정 그룹에 대한 변수 설정 : [그룹이름:vars] 항목에 표기 ```js $ cat inventory [webservers] managed1.example.local [webservers:vars] service=httpd package=httpd firewall_svc=http ``` - 각 호스트에 대한 변수를 별도의 디렉토리(host_vars)에 파일로 저장 - 각 호스트에 대한 변수를 별도의 디렉토리(group_vars)에 파일로 저장 - 이러한 파일은 포맷을 yaml형식(변수: 값)으로 작성하며 확장자는 필요 없음 ```js . ├── ansible.cfg ├── group_vars │ └── webservers ├── host_vars │ └── managed1.example.local ├── http.yml ├── inventory └── webservice.yaml $ cat ./group_vars/webservers package: httpd service: httpd firewall_svc: http ``` 변수 호출 - \\{\\{ 변수명 }} : 어느 위치에 들어가느냐에 따라 \"\" 추가 위치가 달라짐 - string이 들어가는 라인의 맨 앞 : 전체 string의 맨 앞과 맨 뒤에 \" ; ex. \"{{ package }} package is installed\" - string이 들어가는 라인의 중간 : \" 추가하지 않음 ; ex. firewall {{ firewall_svc }} service is opened - 변수 하나만 들어가는 라인 : 변수 앞뒤로 \" ; ex. \"{{ service }}\" - 플레이범위에서 변수 선언 ```js $ cat webservice2.yaml --- - name: webserver is ready hosts: webservers become: true vars: package: httpd service: httpd firewall_svc: http tasks: - name: \"{{ package }} package is installed\" yum: name: \"{{ package }}\" state: latest - name: \"{{ service }} service is enabled and started\" service: name: \"{{ service }}\" enabled: true state: started - name: firewall {{ firewall_svc }} service is opened firewalld: service: \"{{ firewall_svc }}\" state: enabled permanent: true ... ``` - 플레이범위에서 변수 파일 선언 ```js $ cat http.yaml package: httpd service: httpd firewall_svc: http $ cat webservice2.yaml --- - name: webserver is ready hosts: webservers become: true vars_files: - http.yml tasks: - name: \"{{ package }} package is installed\" yum: name: \"{{ package }}\" state: latest - name: \"{{ service }} service is enabled and started\" service: name: \"{{ service }}\" enabled: true state: started - name: firewall {{ firewall_svc }} service is opened firewalld: service: \"{{ firewall_svc }}\" state: enabled permanent: true ... ``` - 인벤토리에서 호스트범위, 그룹범위에 변수 선언 - 아래 예시의 경우, dbservers그룹에 managed3이 있었다면 service 변수 호출이 되지 않아서 오류가 발생했을 것 ```js $ cat inventory [webservers] managed1.example.local [dbservers] managed2.example.local service=mariadb #호스트범위 변수 선언 : 해당 호스트 호출시 사용 [dbservers:vars] #그룹범위 변수 선언 : 해당 그룹에 속하는 호스트 호출시 사용 package=mariadb-server firewall_svc=mysql [allservers:children] webservers dbservers $ cat webservice2.yaml --- - name: dbserver is ready hosts: dbservers become: true tasks: - name: \"{{ package }} package is installed\" yum: name: \"{{ package }}\" state: latest - name: \"{{ service }} service is enabled and started\" service: name: \"{{ service }}\" state: started enabled: yes - name: firewall {{ firewall_svc }} service is opened firewalld: service: \"{{ firewall_svc }}\" state: enabled permanent: yes ... ``` - 특정 디렉토리에 호스트범위, 그룹범위 변수 파일 선언 - 아래 예시를 사용하면 webservers와 dbservers 따로 플레이 작성하던 것을 하나로 통합 가능 ```js $ mkdir group_vars $ cat > group_vars/webservers service: httpd package: httpd firewall_svc: http $ cat > group_vars/dbservers service: mariadb package: mariadb-server firewall_svc: mysql $ cat webservice2.yaml --- - name: webservers and dbservers are ready hosts: webservers, dbservers become: true tasks: - name: \"{{ package }} package is installed\" yum: name: \"{{ package }}\" state: latest - name: \"{{ service }} service is enabled and started\" service: name: \"{{ service }}\" enabled: true state: started - name: firewall {{ firewall_svc }} service is opened firewalld: service: \"{{ firewall_svc }}\" state: enabled permanent: true ... ``` 변수의 배열 - ex. 사용자 추가를 위한 변수 선언 - 단순 변수 형태 ```js user1_id user1_uid user1_homedir user1_login_shell user2_id user2_uid user2_homedir user2_login_shell ``` - 배열 형태 ```js user1 id uid homedir login_shell user2 id uid homedir login_shell ``` - 사용자들이 저장된 배열 ```js users user1 id uid homedir login_shell user2 id uid homedir login_shell ``` 변수 호출방식 - users.user1.id - users['user1']['id'] 명령 출력 캡쳐 - register : 모듈 실행시 실행 결과를 지정한 이름의 변수에 저장하는 기능 (모듈 내에서 작동하는 기능임) - debug : 변수의 값 등을 출력할 수 있는 모듈 ```js $ cat test.yaml --- - name: register and debug test hosts: webservers become: true tasks: - name: install package yum: name: tree state: latest register: result - name: print result debug: var: result ... ``` 변수의 배열 출력 - 목록이나 사전을 사용하지 않는 유형 ```js $ cat vartest.yaml --- - name: variable test hosts: webservers vars: user1_id: alice user1_uid: 10000 user1_homedir: /home/alice user2_id: bob user2_uid: 10001 user2_homedir: /home/bob tasks: - name: print username debug: var: user1_id - name: print user uid debug: var: user1_uid - name: print user home directory debug: var: user1_homedir ... ``` - 목록 형태의 변수 유형 ```js $ cat vartest.yaml --- - name: variable test hosts: webservers vars: user1: - alice - 10000 - /home/alice user2: - bob - 10001 - /home/bob tasks: - name: print username debug: var: user1[0] - name: print user uid debug: var: user1[1] - name: print user home directory debug: var: user1[2] - name: print user debug: var: user1 ... ``` - 사전 형태의 변수 유형 ```js $ cat vartest.yaml --- - name: variable test hosts: webservers vars: user1: id: alice uid: 10000 homedir: /home/alice user2: id: bob uid: 10001 homedir: /home/bob tasks: - name: print username debug: var: user1['id'] - name: print user uid debug: var: user1.uid - name: print user home directory debug: var: user1.homedir - name: print user debug: var: user1 ... ``` ```js $ cat vartest.yaml --- - name: variable test hosts: webservers vars: users: user1: id: alice uid: 10000 homedir: /home/alice user2: id: bob uid: 10001 homedir: /home/bob tasks: - name: print username debug: var: users['user1']['id'] - name: print user uid debug: var: users.user1.uid - name: print user home directory debug: var: users.user1.homedir - name: print users debug: var: users ... ``` 팩트 (Ansible Facts) Ansible Facts - Ansible이 대상 시스템으로부터 자동으로 수집한 정보 - 수집한 정보를 변수 형태로 저장 - 대상 시스템의 상태를 확인하고 상태에 따라 조치하도록 하기 위하여 사용 - 플레이북을 작성하고 실행 시 기본적으로 각 플레이 시작 단계에서 수행 - 필요에 따라 팩트 수집을 해제할 수 있음 - gather_facts 항목을 플레이에 설정 ```js --- - name: variable test hosts: webservers gather_facts: no tasks: ... ``` - 필요에 따라 직접 팩트 수집을 수행할 수 있음 : setup (모듈) - ex. ansible -m setup webservers - 기본적으로 setup 모듈에 수집할 항목들이 지정되어 있음 - ansible_facts : setup 모듈에 의해 수집된 팩트 정보가 저장되는 변수 - ansible_facts.[팩트항목] 혹은 ansible_fact['팩트항목'] 형태로 각 팩트에 접근 - hostname : 짧은 호스트 이름 (도메인 이름 제외) - fqdn : 전체 호스트 이름 (도메인 이름 포함) - default_ipv4.address : 대상의 IP주소 정보 - interfaces : 네트워크 인터페이스 정보 - kernel : 커널 정보 (버전) - devices.sda.partitions.sda1.size : 장치 정보 ```js --- - name: Ansible Facts test hosts: webservers tasks: - name: print fact variable value debug: var: ansible_facts.hostname - name: Ansible Facts test2 hosts: webservers tasks: - name: print fact variable value debug: var: ansible_facts['hostname'] ... ``` - setup 모듈을 ad-hoc 방식으로 실행할 경우, ansible_facts 변수의 하위 항목이 구식 표기방법으로 표시됨 - ex. ansible_hostname, ansible_fqdn 사용자 지정 Facts - 기본 Ansible Facts와 같이 setup에 의해서 수집되는 데이터를 사용자가 직접 지정 - 팩트로 제공할 내용을 managed host에 파일 형태로 미리 작성해놓아야 함 - /etc/ansible/facts.d 디렉토리 내에 .fact로 끝나는 이름으로 작성 ```js [root@managed1 ~]# cat /etc/ansible/facts.d/test.tact [users] user1=alice user2=bob [webservice] package=httpd service=httpd firewall_svc=httpd ``` - control node에서 확인 방법 - ansible -m setup webservers \\| less - /ansible_local 을 입력하면 검색됨 ",
    "url": "/docs/daily-learning-log/20210407.html",
    "relUrl": "/docs/daily-learning-log/20210407.html"
  },"73": {
    "doc": "2021-04-07",
    "title": "2021-04-07",
    "content": " ",
    "url": "/docs/daily-learning-log/20210407.html",
    "relUrl": "/docs/daily-learning-log/20210407.html"
  },"74": {
    "doc": "2021-04-08",
    "title": "파일 다루기",
    "content": "파일 관리 관련 모듈 - file - copy - fetch - lineinfile - blockinfile - stat file module - 다른 파일 관리 모듈들의 기본 동작 - 파일 자체에 대한 속성 설정 - 소유권 - 권한 - SELinux 컨텍스트 - Timestamp - 기본적인 파일 생성/제거 용도로 사용 ```js --- - name: File module test hosts: webservers gather_facts: no tasks: - name: file module test - /tmp/test file: path: /tmp/test state: touch ``` ```js --- - name: File module test hosts: webservers gather_facts: no tasks: - name: file module test - /tmp/test file: path: /tmp/test2 state: touch owner: user group: wheel mode: 0640 ``` ```js --- - name: File module test hosts: webservers gather_facts: no tasks: - name: file module test - /tmp/test file: path: /tmp/test3 state: touch owner: root group: root mode: 0600 setype: default_t ``` 참고 : SELinux 컨텍스트 규칙 변경 모듈 - sefcontext - file 모듈의 setype은 chcon과 같이 파일의 컨텍스트 타입을 직접 지정 - 규칙을 지정할 경우 sefcontext 모듈 사용 - 규칙이 지정되어도, 즉시 반영되지는 않음 - 규칙을 반영하기 위해서는 command, shell 등의 모듈을 사용하여 restorecon 명령을 직접 수행하여야 함 ```js EXAMPLES: - name: Allow apache to modify files in /srv/git_repos sefcontext: target: '/srv/git_repos(/.*)?' setype: httpd_git_rw_content_t state: present - name: Apply new SELinux file context to filesystem command: restorecon -irv /srv/git_repos ``` 파일 복사 모듈 : copy, fetch - copy - ansible이 실행되는 control node의 파일을 managed host에게 복사 - src로 특정 파일을 지정하거나, content로 파일 내용을 작성 ```js --- - name: File module test hosts: webservers gather_facts: no become: true tasks: - name: copy module test - /etc/hosts copy: src: /etc/hosts dest: /etc/hosts ``` ```js --- - name: File module test hosts: webservers gather_facts: no become: true tasks: - name: copy module test - /etc/motd copy: dest: /etc/motd content: \"Hello my Server!!!\" ``` - fetch - copy와 반대로 각 managed host에 있는 파일을 control node로 복사 ```js --- - name: File module test hosts: webservers gather_facts: no become: true tasks: - name: fetch module test fetch: src: /etc/passwd dest: /tmp ``` 내용 추가 모듈 : lineinfile, blockinfile - lineinfile : 지정한 파일에 입력한 텍스트 라인을 추가 ```js --- - name: File module test hosts: all gather_facts: no become: true tasks: - name: lineinfile test lineinfile: path: /etc/hosts line: '192.168.100.23 managed3 managed3.example.local' state: present ``` - blockinfile : 지정한 파일에 입력한 텍스트 블록을 추가 ```js --- - name: File module test hosts: all gather_facts: no become: true tasks: - name: blockinfile test blockinfile: path: /etc/hosts block: | 192.168.100.24 managed4 managed4.example.local 192.168.100.25 managed5 managed5.example.local 192.168.100.26 managed6 managed6.example.local state: present ``` 파일 상태 정보 조회 모듈 : stat (= 리눅스 명령어 stat) ```js --- - name: File module test hosts: all gather_facts: no become: true tasks: - name: stat module test stat: path: /tmp/test register: result - name: print file stat debug: var: result['stat']['checksum'] ``` template - 모든 값이 fix 되어 있지 않고, 일부 항목을 변경할 수 있는 파일 - jinja2: template에서 사용하는 유형 - \\{\\{ 변수명 }} : 변수의 값을 입력하여 템플릿 생성 - {# 주석 #} : 템플릿 내에 주석 사용 - {\\% 논리구조 등 %} : jinja2 템플릿의 고급 사용 - 템플릿에서 사용 가능한 변수 : ansible 내부 변수, 팩트 변수 ```js $ cat template.j2 System name : {{ ansible_facts.fqdn }} System OS : {{ ansible_distribution }} System version : {{ ansible_facts['distribution_version'] }} System administrator : {{ system_admin }} ``` ```js --- - name: create motd file hosts: all become: true tasks: - name: create motd file using template template: src: ./template.j2 dest: /etc/motd owner: root group: root mode: 0644 ``` ```js $ mkdir host_vars $ cat > host_vars/managed1.example.local system_admin: admin1@example.local $ cat > host_vars/managed2.example.local system_admin: admin2@example.local ``` 암호화 기능 - Playbook, vars_files 등 평문 형태로 되어 있는 파일들을 보호하기 위한 방법 - Secret = Ansible Vault - AES256 방식 암호화 수행 - 서브커맨드 종류 (ansible-vault --help로 확인 가능) - create : 새로운 암호화 파일 생성 - view : 암호화 된 파일 보기 - edit : 암호화 된 파일 수정 - encrypt : 기존 파일을 암호화 - decrypt : 암호화 된 파일을 해제 - rekey : 암호 키 변경 ```js $ ansible-vault create secret_file.yml New Vault password: Confirm New Vault password: --- - name: secret file hosts: all tasks: - name: echo hello debug: msg: \"Hello\" ... ``` - 암호화 된 파일을 ansible-playbook 명령으로 사용할 경우 - --ask-vault-pass : 암호 직접 입력 - --vault-id @prompt : 압호 직접 입력 - --vault-password-file : 파일 형태로 저장되어 있는 암호를 사용 - 암호 파일만 chmod 600처럼 소유자만 읽고 쓰기 가능하도록 설정하여 보안 강화 가능 참고!!! 항상 명령어 관련 설명은 --help나 man 명령어 써서 확인하기! - ex. ansible-vault --help ",
    "url": "/docs/daily-learning-log/20210408.html",
    "relUrl": "/docs/daily-learning-log/20210408.html"
  },"75": {
    "doc": "2021-04-08",
    "title": "2021-04-08",
    "content": " ",
    "url": "/docs/daily-learning-log/20210408.html",
    "relUrl": "/docs/daily-learning-log/20210408.html"
  },"76": {
    "doc": "2021-04-09",
    "title": "작업 제어",
    "content": "작업 제어 - 반복문 - 조건문 - 핸들러 - 오류 처리 반복문 (Loop) - loop에서 쓸 항목들은 {{ item }}이라는 변수로 쓴다. - loop에서 쓸 항목들은 배열 형태여야 한다. - 아래 예시들은 모두 같은 task를 진행한다. ```js # 기본 실행 --- - name: service start hosts: webservers become: true tasks: - name: install service httpd, mariadb-server yum: name: - httpd - mariadb-server state: latest - name: start service httpd service: name: httpd state: started - name: start service mariadb service: name: mariadb state: started ``` ```js # loop: 밑에 항목을 나열한다. --- - name: service start hosts: webservers become: true tasks: - name: install service httpd, mariadb-server yum: name: - httpd - mariadb-server state: latest - name: start service httpd service: name: \"{{ item }}\" state: started loop: - httpd - mariadb ``` ```js # loop: 밑에 나열할 항목들은 다시 playbook 초반에 vars: 를 이용하여 변수로 만들 수 있다. --- - name: service start hosts: webservers become: true vars: services: - httpd - mariadb tasks: - name: install service httpd, mariadb-server yum: name: - httpd - mariadb-server state: latest - name: start service httpd service: name: \"{{ item }}\" state: started loop: \"{{ services }}\" ``` ```js # vars: 에 딕셔너리형의 배열 형태로 선언하여 모든 task를 아래와 같이 일관성있게 작성할 수 있다. --- - name: service start hosts: webservers become: true vars: svcpkg: - service: httpd package: httpd - service: mariadb package: mariadb-server tasks: - name: install service httpd, mariadb-server yum: name: \"{{ item.package }}\" state: latest loop: \"{{ svcpkg }}\" - name: start service httpd service: name: \"{{ item.service }}\" state: started loop: \"{{ svcpkg }}\" ``` 반복문 + register - 반복문을 사용하여 register로 결과 저장시 결과물 또한 배열 형태로 모두 저장됨 ```js --- - name: loop register test hosts: webservers tasks: - name: Echo with loop shell: \"echo Hello {{ item }}!\" loop: - Kim - Park - Lee register: result - name: print result debug: var: result ``` ```js --- - name: loop register test hosts: webservers tasks: - name: Echo with loop shell: \"echo Hello {{ item }}!\" loop: - Kim - Park - Lee register: result - name: print result debug: var: result['results'][0]['rc'] ``` 실습 - webservers에 설치할 패키지: httpd, firewalld - webservers에 구동할 서비스: httpd, firewalld - dbservers에 설치할 패키지: mariadb-server, firewalld - dbservers에 구동할 서비스: mariadb, firewalld ```js $ cat group_vars/webservers svcpkg: - service: httpd package: httpd - service: firewalld package: firewalld $ cat group_vars/dbservers svcpkg: - service: mariadb package: mariadb-server - service: firewalld package: firewalld $ cat install_with_loop.yml --- - name: install packages and start services with each group vars hosts: webservers, dbservers become: true tasks: - name: Install package yum: name: \"{{ item.package }}\" state: latest loop: \"{{ svcpkg }}\" - name: Start service service: name: \"{{ item.service }}\" state: started enabled: true loop: \"{{ svcpkg }}\" ``` 조건문 - 조건을 설정하여 작업의 수행 여부를 결정 - 팩트 정보를 사용하여 조건을 확인하는 경우가 많음 - when 사용. 작업의 이름과 동일한 위치로 호출 ```js - name: when test yum: name: httpd state: latest when: ``` - 조건식 사용방법 - 연산자 - 산술비교 : ==, !=, >, =, is (not) defined - bool 타입의 변수 : (not) - 목록 내의 항목 존재여부 : in - 복수 조건 사용 - 논리합 : or - 논리곱 : and - 조건을 목록 형태로 작성 : 논리곱으로 적용됨 - 조건식 사용시 조건의 내용이 길어질 경우 다음 줄에 작성 가능 ```js when: > ( or ) and ( or ) when: > ( or > and ( or ) ``` - 조건식과 반복문 함께 사용 - 조건식에 item을 사용하여 loop에 지정된 항목으로 조건 검사 ```js - name: install package if enough space yum: name: package_name state: latest loop: \"{{ ansible_facts.mounts }}\" when: item.mount == \"/\" and item.size_available > 1000000000 ``` 실습 1 - 패키지 설치 : yum 모듈을 사용해서 패키지를 설치 - 조건 : OS가 redhat, centos, fedora 중 하나일 때 ```js $ cat when.yaml --- - name: Install package when true hosts: webservers become: true vars: os_list: - CentOS - RedHat - Fedora tasks: - name: yum install tree yum: name: tree state: latest when: ansible_distribution in os_list ``` 실습2 - 서비스 이름과 재시작여부를 포함하고 있는 변수를 사용하여 loop를 수행 - 조건 : 재시작여부 변수의 값에 따라 실행 여부 결정 ```js --- - name: when test 2 hosts: webservers become: true vars: svcs: - name: httpd restart: true - name: sshd restart: false tasks: - name: restart service service: name: \"{{ item.name }}\" state: restarted loop: \"{{ svcs }}\" when: item.restart ``` 실습3 - register 와 조건문을 함께 사용하여 command, shell 등의 모듈의 실행결과 판단 ```js --- - name: service running check hosts: webservers become: true tasks: - name: check httpd service command: /usr/bin/systemctl is-active httpd.service ignore_errors: true register: result - name: start httpd service: name: httpd state: started when: result.rc != 0 ``` 핸들러 (Handler) - notify / handler 세트로 동작 - notify : 모듈 실행 시 changed 결과가 나올 경우 핸들러에 실행 통지 - handler : 실행할 내용을 명시 - 핸들러 동작 특성 - notify가 있는 위치에서 핸들러를 실행하는 것이 아님 - notify는 핸들러를 사용할 것을 통지만 하고, 핸들러는 모든 task가 완료된 후에 실행 - 핸들러는 여러 차례 호출된다고 하더라도 한 번만 실행 - 핸들러가 여러 개 있고 여러 핸들러가 실행될 경우, 핸들러의 notify 순서와 무관하게 handler에 명시된 순서대로 실행 - 예시 - 일반적인 프로세스 - 웹 서비스 설치 - 웹 서비스 컨텐츠 파일 복사 - 웹 서비스 설정 파일 복사 - 웹 서비스 재실행 - 핸들러 사용시 프로세스 - 웹 서비스 설치 - 웹 서비스 컨텐츠 파일 복사 - 웹 서비스 설정 파일 복사 - 웹 서비스 재실행 (설정 파일이 변경되면) ```js --- - name: Web service hosts: webservers become: true tasks: - name: install httpd yum: name: httpd state: latest - name: copy contents copy: dest: /var/www/html/index.html content: \"Hello World\" - name: copy config file copy: src: ./httpd.conf dest: /etc/httpd/conf/httpd.conf notify: - restart httpd handlers: - name: restart httpd service: name: httpd state: restarted ``` ```js --- - name: Web service hosts: webservers become: true tasks: - name: install httpd yum: name: httpd state: latest - name: copy contents copy: dest: /var/www/html/index.html content: \"Hello World 3\" notify: echo hello - name: copy config copy: content: \"Hello World 3\" dest: /tmp/httpd.conf notify: - restart httpd handlers: - name: restart httpd service: name: httpd state: restarted - name: echo hello debug: msg: \"Hello\" ``` 작업 오류 처리 에러 - 발생하면 즉각 중지 (뒤의 프로세스들은 실행하지 않음) ignore_errors - 에러 발생시 중지하지 않고 다음 작업을 실행하도록 진행 - 작업 내부에 사용 force handlers - 플레이 내부에 사용 (tasks 내부 아님!!) ; true, false - true로 설정시, 작업의 오류로 인해 플레이가 중지되더라도 트리거 된 핸들러는 실행하고 종료 - 작업 오류 시 즉지 중지됨 ( 트리거 된 핸들러는 실행한다는 점이 ignore_error와 다름) ```js --- - name: Web service hosts: webservers become: true force_handlers: true tasks: - name: copy contents copy: dest: /var/www/html/index.html content: \"Hello World 6\" notify: echo hello - name: error yum: name: abcdefjhg state: latest - name: copy config copy: content: \"Hello World 6\" dest: /tmp/httpd.conf notify: - restart httpd handlers: - name: restart httpd service: name: httpd state: restarted - name: echo hello debug: msg: \"Hello\" ``` changed_when - 작업의 changed 여부를 직접 지정 - 조건을 만족할 경우 결과를 changed로 전달 - 조건을 만족하지 않을 경우 결과를 ok로 전달 ```js --- - name: changed_when test hosts: webservers tasks: - name: copy file copy: content: \"Hello World 1\" dest: /tmp/helloworld changed_when: false ``` failed_when - 작업의 failed 여부를 직접 지정 - 조건을 만족할 경우 결과를 failed로 전달 ```js --- - name: failed when test hosts: webservers tasks: - name: sed command 1 command: /usr/bin/sed -n '/root/p' /etc/passwd - name: sed command 2 command: /usr/bin/sed -n '/abcdefg/p' /etc/passwd ``` ```js --- - name: failed when test hosts: webservers tasks: - name: sed command 1 command: /usr/bin/sed -n '/root/p' /etc/passwd - name: sed command 2 command: /usr/bin/sed -n '/abcdefg/p' /etc/passwd register: result failed_when: result.stdout == \"\" ``` 블록 처리 블록 (Block) - 처리가 되는 단위로 묶음 - 예시 - when의 조건을 사용할 경우 ```js --- - name: block test hosts: webservers tasks: - name: install package block: - yum: name: httpd state: latest - name: start service service: name: httpd state: restarted when: ansible_facts.distribution == \"CentOS\" ``` - block / rescue / always 구조에서 사용 - block : 실행할 내용 - rescue : block 실행 중 오류 발생 시 실행할 내용 - always : 무조건 실행할 내용 ```js --- - name: block rescue always test hosts: webservers tasks: - name: Block block: - name: echo hello 1 debug: msg: \"hello 1\" rescue: - name: echo hello 2 debug: msg: \"hello 2\" always: - name: echo hello 3 debug: msg: \"hello 3\" ``` ```js --- - name: block rescue always test hosts: webservers tasks: - name: Block block: - name: echo hello 1 debug: msg: \"hello 1\" - name: failed task fail: rescue: - name: echo hello 2 debug: msg: \"hello 2\" always: - name: echo hello 3 debug: msg: \"hello 3\" ``` ",
    "url": "/docs/daily-learning-log/20210409.html",
    "relUrl": "/docs/daily-learning-log/20210409.html"
  },"77": {
    "doc": "2021-04-09",
    "title": "2021-04-09",
    "content": " ",
    "url": "/docs/daily-learning-log/20210409.html",
    "relUrl": "/docs/daily-learning-log/20210409.html"
  },"78": {
    "doc": "markdown manual",
    "title": "markdown manual",
    "content": "Summary () {: .text-delta } 1. TOC {:toc} Important Text can be **bold**, _italic_, or ~~strikethrough~~. [Link to another page](another-page). There should be whitespace between paragraphs. There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project. # [](#header-1)Header 1 This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere. ## [](#header-2)Header 2 > This is a blockquote following a header. > > When something is important enough, you do it even if the odds are not in your favor. ### [](#header-3)Header 3 ```js // Javascript code with syntax highlighting. var fun = function lang(l) { dateformat.i18n = require('./lang/' + l) return true; } ``` ```ruby # Ruby code with syntax highlighting GitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, \"= #{version}\") end ``` #### [](#header-4)Header 4 `with code not transformed` * This is an unordered list following a header. * This is an unordered list following a header. * This is an unordered list following a header. ##### [](#header-5)Header 5 1. This is an ordered list following a header. 2. This is an ordered list following a header. 3. This is an ordered list following a header. ###### [](#header-6)Header 6 | head1 | head two | three |:-------------|:------------------|:------| ok | good swedish fish | nice | out of stock | good and plenty | nice | ok | good `oreos` | hmm | ok | good `zoute` drop | yumm | ### There's a horizontal rule below this. * * * ### Here is an unordered list: * Item foo * Item bar * Item baz * Item zip ### And an ordered list: 1. Item one 1. Item two 1. Item three 1. Item four ### And a nested list: - level 1 item - level 2 item - level 2 item - level 3 item - level 3 item - level 1 item - level 2 item - level 2 item - level 2 item - level 1 item - level 2 item - level 2 item - level 1 item ### Nesting an ol in ul in an ol - level 1 item (ul) 1. level 2 item (ol) 1. level 2 item (ol) - level 3 item (ul) - level 3 item (ul) - level 1 item (ul) 1. level 2 item (ol) 1. level 2 item (ol) - level 3 item (ul) - level 3 item (ul) 1. level 4 item (ol) 1. level 4 item (ol) - level 3 item (ul) - level 3 item (ul) - level 1 item (ul) ### And a task list - [ ] Hello, this is a TODO item - [ ] Hello, this is another TODO item - [x] Goodbye, this item is done ### Small image ![](https://assets-cdn.github.com/images/icons/emoji/octocat.png) ### Large image ![](https://guides.github.com/activities/hello-world/branching.png) ### Definition lists can be used with HTML syntax. Name Godzilla Born 1952 Birthplace Japan Color Green #### Multiple description terms and values Term : Brief description of Term Longer Term : Longer description of Term, possibly more than one line Term : First description of Term, possibly more than one line : Second description of Term, possibly more than one line Term1 Term2 : Single description of Term1 and Term2, possibly more than one line Term1 Term2 : First description of Term1 and Term2, possibly more than one line : Second description of Term1 and Term2, possibly more than one line ### More code ``` Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. ``` ``` The final element. ``` ",
    "url": "/docs/",
    "relUrl": "/docs/"
  },"79": {
    "doc": "Python-study",
    "title": "Python study index page",
    "content": " ",
    "url": "/docs/python-study/",
    "relUrl": "/docs/python-study/"
  },"80": {
    "doc": "Python-study",
    "title": "Python-study",
    "content": " ",
    "url": "/docs/python-study/",
    "relUrl": "/docs/python-study/"
  },"81": {
    "doc": "Daily-learning-log",
    "title": "Daily learning log index page",
    "content": " ",
    "url": "/docs/daily-learning-log/",
    "relUrl": "/docs/daily-learning-log/"
  },"82": {
    "doc": "Daily-learning-log",
    "title": "Daily-learning-log",
    "content": " ",
    "url": "/docs/daily-learning-log/",
    "relUrl": "/docs/daily-learning-log/"
  }
}
